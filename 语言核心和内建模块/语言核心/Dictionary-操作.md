# Dictionary 操作

* Python 提供了`多种`适用于`字典`的`操作`。

* 由于`字典`是`容器`，因此内置的 `len` 函数可以将字典作为其参数，并`返回`字典中的`项`(`键值对`)`数`。

* `字典`是`可迭代对象的`，因此可以将其传递给任何带有可迭代对象参数的函数。

* `迭代时`，以任意顺序`产出`字典的 `key`。 如，对于任何字典 D，`min(D)` 返回 D 中`最小`的 `key`。

* 在 Python `3.6` 中重新实现了字典；可以按`插入顺序`迭代 `key`。

## 关系测试

* `k in D` 检查`对象 k` 是否为`字典 D` 中的 `key`。如果 `k` `是` `D` 中的 `key`，返回 `True`，`否`则返回 `False`。`k not in D` 等价于 `not (k in D)`。

## 索引访问 Dictionary

* 要表示当前与`键 k` 关联的`字典 D` 中的`值`，请使用索引访问：`D[k]`。使用字典中`不存在`的`键`进行`索引`会`引发异常`。

```python
d = {'x':42, 'y':3.14, 'z':7}
d['x'] # 42
d['z'] # 7
d['a'] # 抛出 KeyError 异常
```

* `简单赋值`给使用字典中`不存在的键`索引的字典(如，`D[newkey] = value`)是有效的操作，其结果是将`键和值`添加为字典中的`新项(键值对)`。

```python
d = {'x':42, 'y':3.14}
d['a'] = 16 # d == {'x':42, 'y':3.14, 'a':16}
```

* `del D[k]` 从`字典 D` 中`删除`键为 k 的`项`。当 `k 不是字典 D 中的键`时，`del D[k]` 将引发 `KeyError` 异常。

```python
d = {'x':42, 'y':3.14}
del d['x'] # d == {'y':3.14}
del d['z'] # 抛出 KeyError 异常
```

## Dictionary 的方法

* `字典对象`提供了一些方法。 `不可变方法`不改变其应用的对象而`返回结果`；`可变方法`可以改变其应用的对象。

* 在下表中，`D` 和 `D1` 表示任何字典对象，`k` 表示任何可哈希对象，`x` 表示任何对象。

| 方法 | 描述 | 可变性(是否能改变 D) |
| :-: | :-: | :-: |
| D.copy() | 返回`字典`的`浅拷贝`副本(该副本的项与 D 的`项`是`同一对象`，并`非拷贝`)，结果与 `dict(D)` 一样 | 不可变 |
| D.get(k[, x]) | 当 `k` 是 D 中的`键`时，返回 `D[k]`。`否则`，返回 `x`(如果`未给出 x`，则返回 `None`) | 不可变 |
| D.items() | 在 `v2` 中，`返回`一个新`列表`，其中包含 D 中的所有`项`(`键值对`)；在 `v3` 中，`返回`一个类型为 `dict_items` 的可迭代对象(`不是`一个`列表`) | 不可变 |
| D.iteritems() | 返回 D 中所有`项`(`键值对`)的`迭代器`(仅 `v2`) | 不可变 |
| D.iterkeys() | 返回 D 中所有`键`的`迭代器`(仅 `v2`) | 不可变 |
| D.itervalues() | 返回 D 中所有`值`的`迭代器`(仅 `v2`) | 不可变 |
| D.keys() | 在 `v2` 中，`返回`一个包含 D 中所有`键`的新`列表`；在 `v3` 中，`返回`一个类型为 `dict_keys` 的可迭代对象(`不是`一个`列表`) | 不可变 |
| D.values() | 在 `v2` 中，`返回`一个包含 D 中所有`值`的新`列表`；在 `v3` 中，`返回`一个类型为 `dict_values` 的可迭代对象(`不是`一个`列表`) | 不可变 |
| D.clear() | 从 `D` `删除`所有`项`，最后 `D` 为`空字典` | 可变 |
| D.pop(k[, x]) | 当 k `是` D 中的`键`时，`移除`并`返回` `D[k]`； `否`则，返回 `x`(在`未给出 x` 时，抛出 `KeyError` 异常) | 可变 |
| D.popitem() | `删除`并`返回`任意`项`(`键值对`) | 可变 |
| D.setdefault(k[, x]) | 当 k `是` D 中的`键`时，返回 `D[k]`。 `否`则，将 `D[k]` 设置为 `x`(如果`未给出 x`，则设置为 `None`) 并`返回 x` | 可变 |
| D.update(D1) | 对于`映射 D1` 中的每个 `k`，将 `D[k]` 设置为 `D1[k]` | 可变 |

* `项`，`键`和`值`的方法以`任意顺序`返回它们的`结果`(在 `v2` 中是`列表`；在 `v3` 中是类型为 `dict_?` 的`可迭代对象`)。

* 同一个字典的`项`，`键`和`值`方法返回的结果中，`项`，`键`和`值`的顺序是可以对应的。

* 仅在 `v2` 中存在的`方法`，`iteritems`，`iterkeys` 和 `itervalues` 返回`与`这些`列表对应`的`迭代器`。

* `迭代器`或 `dict_? 实例`消耗的`内存`少于列表，但在`迭代`该`字典`的任何`迭代器`时，绝对`不能修改`字典中的`键`(`如`，绝对不能`添加`或`删除`键)。

* 在 `v2` 中，`项`，`键`或`值`方法`返回`的`列表`。在 `v3` 中，需要`显式创建列表`，如 `list(D.keys())`。

* `直接`在`字典 D` 上进行`迭代`，在 `v2` 中`等价于`在 `D.iterkeys()` 上进行`迭代`，在 `v3` 中`等价于`在 `D.keys()` 上进行`迭代`。

* `v3` 的 `dict_? 类型`对象都是`可迭代对象`。`dict_items` 和 `dict_keys` 还实现了 `set` 的`不可变方法`，其`行为`非常`类似`于 `frozensets`。`dict_values` `没有`，因为`它与其他不同`，它`可能`包含一些`重复项`。

* `popitem` 方法可用于`字典`上的`破坏性迭代`。`items` 方法和 `popitem` 方法都`返回`字典`项(键值对)`。当在循环过程中“`消耗`” `字典` 时，可以`节省内存`。这使得 `popitem` 可以`应用`在对`庞大字典`的`迭代遍历`上

* `D.setdefault(k, x)` `返回`与 `D.get(k, x)` `相同`的`结果`，当 `k 不是 D 中的键`时，setdefault 也`具有`将`值 x 绑定到 D[k]` 的`副作用`。

* 在现代 Python 中，`很少`直接使用 `setdefault`，因为 `collections.defaultdict` 提供了`类似`的`功能`，而且更加`优雅`和`快速`。

* `pop` 方法`返回`与 `get` `相同`的`结果`。当 `k 是 D 中的键`时，pop 也具有`删除 D[k]` 的`副作用`(当`未指定 x` 且 `k 不是 D 中的键`时，`get 返回 None`，但 `pop 会引发异常`)。

* `update` 方法可以接受`键值对`的`可迭代对象`作为`替代参数`而不是`映射`，并且还可以接受`命名参数`(`key=value`)，`语义`与`调用`内置的 `dict` 类型时传递此类参数的语义`相同`。
