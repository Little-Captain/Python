# 数据类型

* Python 程序的`操作`取决于它处理的`数据`。

* Python 中的`数据值`称为`对象`；`每个对象都有一个类型`。

* 对象的`类型决定`了对象支持哪些`操作`(换句话说就是可以对值执行哪些操作)。

* `类型`还`确定`对象的`属性`和`项`(items)(如果有)以及对象`是否可以更改`。

* 可以更改的对象称为`可变对象`，不能更改的对象是`不可变对象`。

* 内置的 `type`(obj) `函数`接受任何对象作为其参数，并`返回` obj 对象的`类型对象`。

* 当对象 obj 具有类型 type(或其任何子类)时，内置函数 `isinstance(obj, type)` 返回 True。否则，它返回 False。

* Python 具有`基本数据类型`的`内置`类型(例如，`数字`，`字符串`，`元组`，`列表`，`字典`和`集合(Sets)`)。

* 可以创建`自定义类型`，即`类`。

## 数字

* Python 中的`内置数字类型`包括`整数`(在 `v2` 中有 `int` 和 `long` 两种；在 `v3` 中，`整数类型之间没有区别`)，`浮点数`和`复数`。

* 标准库提供的`"十进制模块"`中涵盖了十进制浮点数，以及`"分数模块"`中涵盖了分数。

* 当对数字对象执行`操作`时，会产生一个`新的数字对象`。

* `数字字面量不包含符号`：前导 `+` 或 `-`(如果存在)是`单独的运算符`。

* 为了`直观地评估数字`的`大小`，从 `3.6` 开始，`数字字面量`可以在数字之间或任何基本说明符之后包含`单个下划线`(_)`字符`(如，100_000.000_0001, 0x_FF_FF, 0o7_777, 0b_1010_1010)。

### 整数

|  |  |
| :-: | :-: |
| 1, 23, 3493 | 十进制字面量 |
| 0b010101, 0b110010 | 二进制字面量 |
| 0o1, 0o27, 0o6645 | 八进制字面量 |
| 0x1, 0x17, 0xDA5 | 十六进制字面量 |

* `整数字面量`可以是`十进制`，`二进制`，`八进制`或`十六进制`。

* `十进制字面量`是数字序列，其中`第一位非零`。

* `二进制字面量`以 `0b 开头`，后跟一系列的二进制数字(0或1)。

* 仅在 `v2` 中，`八进制字面量`可以以 `0 开头`，后跟八进制数字序列(0至7)。这种语法可能会产生误导，因此不建议这样做。

* 使用 `0o 后跟一个八进制数字序列`，这种写法在 `v2` 和 `v3` 中`均可使用`，不会产生误导。

* `十六进制字面量`以 `0x 开头`，后跟十六进制数字序列(0-9和A-F(大写、小写均可))。

* `整数字面量没有定义上限`(仅在 `v2` 中，如果`大于 sys.maxint`，则`整数字面量是内置类型 long 的实例`；在 `v3` 中`不`会进行`区分`，而是将 `int 用作所有整数的类型`)。

### 浮点数

|  |  |
| :-: | :-: |
| 0., 0.0, .0, 1., 1.0, 1e0, 1.e0, 1.0e0 | 浮点字面量 |

* `浮点字面量`是由`十进制数字组成的序列`，其中包括`小数点(.)`，`指数后缀(e 或 E，后跟 + 或 -(可选)`，再后跟`一个或多个数字)`，或两者共存。

* `浮点字面量`的`前导字符不能为 e 或 E`；`可以是任何数字或句点(.)`。

* `Python 浮点数对应于 C 的 double`，并`共享其范围和精度的限制`。

* 有关`各个平台上浮点数`的确切`范围和精度`，请参见 `sys.float_info`。

### 复数

* 复数由`两个浮点值`组成，每个浮点值分别代表`实部`和`虚部`。

* 可以通过 `z.real` 和 `z.imag` 访问复数对象 z 的实部和虚部。

* 可以将`虚数字面量`指定为浮点数或十进制字面量，后跟 j 或 J(如，0j, 0.j, 0.0j, .0j, 1j, 1.j, 1.0j, 1e0j, 1.e0j, 1.0e0j)。

* 要表示`任何常数复数`，都`需要`写出`虚数部分`(例如，要表示等于 1 的复数，请使用 1 + 0j 或 1.0 + 0.0j 之类的表达式)。Python 在编译时执行加法或减法。

## 序列(Sequences)

* `序列`是`有序`的`元素容器`，以`整数索引`。

* Python 具有内置的序列类型(包括，`字符串`(bytes 和 Unicode)，`元组`和`列表`。

### 可迭代对象

* 在 Python 中，所有的`序列`都是`可迭代`对象。

* `有界`可迭代对象：最终会`停止`产出元素。

* `无界`可迭代对象：会`一直`产出新元素。

* 所有的`序列`都是`有界`的。

* 通常，`可迭代对象`可以`有界`，也可以`无界`。

* 对于`无界可迭代对象`，请`小心`使用，不加留意地使用它容易产生不会终止的程序(程序最终将耗尽可用内存)。

### 字符串

```python
'This is a literal string' # 使用单引号

"This is another string" # 使用双引号

'I\'m a Python fanatic' # 使用单引号的字符串，其内部的单引号要进行转义

"I'm a Python fanatic" # 使用双引号的字符串，其内部的单引号不用转义。单引号字符串同理。

'A not very long string \
that spans two lines' # 字符串跨行

'A not very long string\n\
that prints on two lines' # 字符串跨行，并内部嵌入换行符

"""An even bigger
string that spans
three lines""" # 三引号字符串

"""\
First line
Second line
""" # 开始无换行，末尾有换行
```

* `字符串对象`(bytes 或 Unicode)是一个`字符序列`，它用于`存储和表示`基于`文本`的`信息`。

* 字节字符串(byte String)，也称为`字节对象`，用于`存储和表示`任意`二进制字节序列`。

* Python 中的`字符串`是`不可变`的：对`字符串`执行`操作`时，`始终会产生一个新的字符串对象`，而不是更改现有的字符串。

* 在 `v2` 中，`未经修饰的字符串字面量`表示`字节字符串`；而在 `v3` 中表示 `Unicode 字符串`。

* 使用`单引号`表示字符串字面量是`推荐`的 Python 样式。

* 要使`字符串文字跨越多条物理行`，可以使用 `\` 作为行的最后一个字符，以指示下一行是连续行。

* 在`三引号`括起来的字符串字面量中，`任意位置的换行符均会被保留`。可以用`三引号跟 \` 作为开头，并在后面加上换行符，这样可以方便调整各行的缩进级别。

* `不能成为三引号的字符串的一部分`的唯一字符是`未转义的反斜杠`。

* 使用`反斜杠转义`可以在`任何一种字符串`中`引入任何字符`。

| 序列 | 意义 | ASCII/ISO 码 |
| :-: | :-: | :-: |
| \\\<newline\> | 忽略行尾 | None |
| \\\\ | 反斜杠本身 | 0x5c |
| \\' | 单引号 | 0x27 |
| \\" | 双引号 | 0x22 |
| \\a | 响铃 | 0x07 |
| \\b | 回退符 | 0x08 |
| \\f | 换页符 | 0x0c |
| \\n | 换行符 | 0x0a |
| \\r | 回车符 | 0x0d |
| \\t | 水平制表符 | 0x09 |
| \\v | 垂直制表符 | 0x0b |
| \\DDD | 八进制数 DDD 代表的字符 | 与提供的一致 |
| \\xXX | 十六进制数 XX 代表的字符 | 与提供的一致 |
| ... | ... | ... |

* `原始字符串`需要在最开始的引号前加上 `r` 或 `R`。

* 在`原始字符串`中的`所有字符`均会按`字面意义处理`，包括反斜杠。

* `原始字符串`语法`适用`于需要`包含反斜杠的字符串`，尤其是`正则`表达式的`模式字符串`。

* 原始字符串`不能`以`奇数`个`反斜杠结尾`：最后一个将被视为转义引号的转义符。

* 在 `Unicode 字符串字面量`中，可以使用 `\u 后跟四个十六进制数字`和 `\U 后跟八个十六进制数字`来表示 Unicode 字符。Unicode 字面量也可以包含转义序列 `\N{name}`，其中 `name` 是`标准 Unicode 名称`。

* 在 `v2` 中的`原始 Unicode 字符串文字`以 `ur 开头`；在 `v2` 中的`原始字节字符串字面量`以 `br 开头`，在 `v3` 中，可以 `br 或 rb 开头`。

| 字符串类型 | v2 | v3 |
| :-: | :-: | :-: |
| `字节`字符串 | 'byte string' | `b`'byte string' |
| `Unicode` 字符串 | `u`'unicode string' | 'unicode string' |
| `原始字节`字符串 | `br`'raw byte string' | `br`'raw byte string' or `rb`'raw byte string' |
| `原始 Unicode` 字符串 | `ur`'raw unicode string' | `r`'raw unicode string' |

* `原始字符串`与`普通字符串`没有区别。它们只是通常的两种字符串类型(字节字符串 和 Unicode 字符串)字面量的`替代语法`。

* `格式化字符串字面量`是 Python `3.6` 中的`新功能`，可以将`格式化表达式注入其中`。格式化字符串字面量`不再表现为常量`，而是可以在`执行时`被`动态评估`。

* 可以`连接相邻的任何类型`(带引号，三引号，原始，字节，带格式，Unicode)的`字符串字面量`，并且`它们之间具有可选的空格`(在 `v3` 中，`不能`以这种方式`连接字节和 Unicode 字符串`)。`编译器`将这些相邻的字符串字面量`连接`成`一个字符串对象`。在 `v2` 中，如果连接中的`任何字面量是 Unicode`，则整个`结果是 Unicode`。

* 以下方式编写长字符串文字可以在多个物理行中可读地显示它，并有机会插入有关字符串部分的注释。

```python
# marypop 的值为：'supercalifragilisticexpialidocious'
marypop = ('supercalifragilistic'
           'expialidocious')
```

### 元组

* `元组`是元素`不可变`的`有序序列`。

* 元组的`元素`可以是`任意对象`，并且各个元素`可以`具有`不同`的`类型`。

* `可以`将`可变对象`(例如列表)用作`元组元素`；但是，最佳实践是`避免`元组包含`可变元素`。

* 要表示元组，需要使用逗号(,)分隔元组的元素；如果每个元素都是字面量，那么这个元组就是一个元组字面量。

* 可以在最后一个元素之后放置一个`多余的逗号`。

* 定义元组时使用`圆括号`是`可选`的。只有在逗号具有其他含义或表示空元组或嵌套元组的情况下，圆括号才是必须的。

* 具有`两个元素`的元组称为`序对`。要创建包含一个元素的元组，必须在这个元素末尾添加逗号。要表示一个空元组，请直接使用一对空括号。

```python
(100, 200, 300) # 圆括号是可选的
(3.14,) # 圆括号是可选的
() # 圆括号不是可选的
```

```python
# 调用内置类型 tuple 来创建元组
tuple('wow') # 传入字符串序列，创建元组。('w', 'o', 'w')
```

* 不带参数的 tuple() 将创建一个空元组 ()。

* 当 x 是可迭代的对象时，`tuple(x)` 将创建一个与 x 中的元素相同的元组。

```python
# 调用内置类型 tuple 来创建元组
tuple('wow') # 传入字符串序列，创建元组。('w', 'o', 'w')
```

```python
# 使用元组生成式创建元组
tuple(i for i in range(12)) # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
```

### 列表

* 列表是`可变`的`有序序列`。列表中的`元素`可以是`任意对象`，并且`可以`具有`不同`的`类型`。

* 要表示列表，需要使用方括号(`[]`)包裹元素，并使用逗号(,)分隔各个元素；如果每个元素都是字面量，那么这个列表就是一个列表字面量。

* 可以在最后一项之后放置一个`多余的逗号`。

* 要表示一个空列表，请使用一对空方括号。

```python
[42, 3.14, 'hello']
[100]
[] # 空列表
```

* 不带参数的 list() 将创建一个空列表 []。

* 当 x 是可迭代的对象时，`list(x)` 将创建一个与 x 中的元素相同的列表。

* 另外，可以使用列表生成式创建列表。

```python
# 调用内置类型 list 来创建列表
list('wow') # 传入字符串序列，创建列表。['w', 'o', 'w']
```

```python
# 使用列表生成式创建列表
[i for i in range(12)] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
# 等价语法
list(i for i in range(12)) # 同上
```

## 集合(Sets)

* Python 中有两个内置的 set 类型，即 `set` 和 `frozenset`，用于表示`无序`的`唯一`元素的集合。

* set 中的`元素`可以具有`不同`的`类型`，但它们`必须`是`可哈希`的。

* `set` 类型的`实例`是`可变`的，因此它`不可哈希`。`frozenset` 类型的`实例`是`不可变`的和`可哈希`的。

* set 类型的实例的元素不能是 set 类型的实例，但可以是 frozenset 类型的实例。

* set 和 frozensets 中的元素是`无序`。

* 要表示一个(nonfrozen, nonempty)的 set，可以使用花括号(`{}`)包裹元素，并使用逗号(,)分隔各个元素；如果每个元素都是字面量，那么这个 set 就是一个 set 字面量。

* 可以在最后一项之后放置一个`多余的逗号`。

* 不带参数的 `set()` 将创建一个`空 set`。空 set 没有字面量表示。`{}` 表示`空字典`。

* 当 x 是可迭代的对象时，`set(x)` 将创建一个与 x 中的元素相同的 set。

* 相似的，可以使用 frozenset 创建 frozenset 类型的实例。

* 另外，可以使用 set 生成式创建 nonfrozen set。

```python
{42, 3.14, 'hello'}
{100}
set() # 空 set (不能使用 {}，因为它是一个空字典)
```

```python
# 调用内置类型 set 来创建 set
set('wow') # 传入字符串序列，创建 set。{'w', 'o', 'w'}
```

```python
# 使用 set 生成式创建 set
{i for i in range(12)} # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
# 等价语法
set(i for i in range(12)) # 同上
```

## 字典

* `映射(mapping)`是由几乎任意值(称为 `key`)`索引`的任意对象(称为 `value`)所组成的集合对象。

* 映射是`可变`的。

* 与 set 类似，它也是`无序`。

* Python 提供了一个内置的映射类型：`字典类型`。

* 字典中的键(`key`)可以是`不同`的`类型`，但它们必须是`可哈希`的。字典中的值(`value`)可以是`任意对象`，并且可以是`任何类型`。字典中的一`项(item)`称为`键/值对(key/value)`。

* 可以将`字典`视为`关联(键值对)无序数组`。

* 要表示字典，需要使用花括号(`{}`)包裹`键值对(用冒号分隔)`，并使用逗号(,)分隔各个键值对；如果每个值(value)都是字面量，那么这个字典就是一个字典字面量。

* 可以在最后一项之后放置一个`多余的逗号`。

* 字典`不允许重复的键`：如果某个键在字典中出现多次，则在生成的字典对象中仅保留具有该键的任意一项。

* `{}` 表示一个`空字典`。

```python
{'x':42, 'y':3.14, 'z':7}
{1:2, 3:4}
{1:'za', 'br':23} # key 具有不同的类型
{} # 空字典
```

* 不带参数的 dict() 将创建一个空字典 {}。

* 在 `dict(x)` 中，当 x 是一个映射时，dict 将创建一个新的字典对象，该对象具有与 x 相同的键和值。

* 在 dict(x) 中，如果 `x 是可迭代的`，则 x 中的元素必须成对，此时 dict(x) 将返回一个字典，该字典的项(键/值对)与 x 中的项相同。如果`一个键值在 x 中出现多次`，则在 x 中具有该键值的最后一项将保留在结果字典中。

* 在调用 dict 时，除了位置参数 x 之外，还可以传递`命名参数`，每个参数的语法均为 `name=value`，其中 `name` 用作`键(str 类型)`，`value` 用作`值`。

* 当调用 dict 时，`同时`传递`位置参数`和`命名参数`时，它们会按上述两条规则添加到结果字典中。

```python
# 调用内置类型 dict 来创建字典
# 这种方式创建字典，不够简洁，但是有时更具可读性
dict(x=42, y=3.14, z=7) # {'x': 42, 'y': 3.14, 'z': 7}
dict([(1, 2), (3, 4)]) # {1: 2, 3: 4}
dict(((1, 2), (3, 4))) # {1: 2, 3: 4}
dict([(1,'za'), ('br',23)]) # {1: 'za', 'br': 23}
dict() # {}
dict([(1,2), (2, 3)], a=1, b=2, c=3) # {1: 2, 2: 3, 'a': 1, 'b': 2, 'c': 3}
```

* 可以通过调用 `dict.fromkeys` 创建字典。`第一个参数`是一个`迭代器`，其`元素`作为字典的`键`；`第二个参数`是与每个键对应的`值`(`所有键最初都映射到相同的值`)。如果省略第二个参数，则默认为 None。

```python
dict.fromkeys('hello', 2) # {'h': 2, 'e': 2, 'l': 2, 'o': 2}
dict.fromkeys([1, 2, 3]) # {1: None, 2: None, 3: None}
```

* 另外，可以使用字典生成式创建字典。

```python
# 使用字典生成式创建字典
{i:i/2 for i in range(3)} # {0: 0.0, 1: 0.5, 2: 1.0}
```

## None

* 内置的 None 表示`空对象`。

* None `没有方法`，也`没有属性`。

* 当需要表明我们`不关心引用的具体对象`时，或需要`指明这里没有对象`时，就可以使用 `None`。

* `没 return 语句的函数，默认返回 None`。

## 可调用的(Callables)

* 在 Python 中，`可调用类型的实例支持调用操作`。

* `函数`是`可调用`的。Python 提供了一些内建函数，同时还支持用户自定义函数。

* `生成器`(generator)也是`可调用`的。

* `类型`(type)也是`可调用`的。例如，dict，list，set，tuple 等等。

* `类对象(用户自定义类型)`也是`可调用`的。通常调用类型会创建该类型的一个新实例。

* `方法`(绑定到类属性上的函数)也是`可调用`的。类的实例提供了一个名为 `__call__` 的特殊方法。

## 布尔值

* 在 Python 中的`任何数据值`，都可作为`真值使用`：`真`或`假`。

* 任何`非零数值`，任何`非空容器`都为`真`。

* 任何`数值类型的零值`，`None`，任何`空容器`都为`假`。

* 使用`浮点数`作为`真值`时要`小心`：使用浮点数时，容易出现`看上去为零`，`其实不为零`的情况。通常`不应该将浮点数进行精确相等的比较`。

* Python 内建类型 `bool` 是 `int 类型`的`子类`。bool 类型`只有两个值`：`True` 和 `False`。字符串表示为：'True' 和 'False'。其对应`数值`(`可参与数值对象的计算`)分别是：`1` 和 `0`。

* `比较运算符`将`返回 bool 值`。

* 可以调用 `bool(x)` 来`创建 bool 值`。x 为真，返回真；x 为假，返回假。

* 一个好的 Python 风格是：如果 `bool(x)` 调用是`多余`的，就`不要使用它`。请使用 `if x:`，永远不要写成这些形式 `if bool(x):`，`if x is True:`，`if x == True:`，`if bool(x) == True:`。

```python
# 可以利用 bool(x) 来计算序列中为真的元素的个数。
# 调用 bool(x) 来保证序列中的每个元素作为 0(False) 或 1(True) 来进行求和计算。
def count_trues(seq):
    # 传递给 sum 函数的是一个生成器(generator)
    return sum(bool(x) for x in seq)
```

* `表达式`为`真`的含义是：`bool(表达式) 将返回 True`。
