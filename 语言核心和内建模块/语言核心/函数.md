# 函数

* 典型的 `Python 程序`中的`大多数语句`都是`函数的一部分`。

* 将代码以`函数的形式`进行组织能使代码更具`条理性`和`可读性`。

* `函数体`中的代码`可能`比`模块顶层`的代码`快`。

* `函数`是`一组`在被`调用`时才`执行`的`语句`。

* Python 提供了许多`内置函数`，并`允许`程序员`定义`自己的`函数`。

* `请求执行函数`称为`函数调用`。

* `调用函数`时，可以通过`参数传递指定的数据`，函数在该数据上执行计算。

* 在 `Python` 中，`函数始终会返回一个结果值`(`没有显式返回任何值`，函数`默认`会`返回 None`)。

* 在 `class 语句`中定义的`函数`称为`方法`。对`函数`的`一般介绍`也`适用`于`方法`。

* 在 `Python` 中，`函数`是`对象`(`值`)，`要和其他对象同等对待`。

* 可以在调用另一个函数时将一个`函数作为参数`传递。同样，一个函数可以返回另一个`函数作为`调用的`返回值`。

* 和任何其他对象一样，`函数`可以`绑定到变量`，可以是`容器中的项`，也可以是`对象的属性`。

* 函数也可以是`字典中的键`。如果您需要`快速`找到给定`函数`的`逆函数`，则可以定义一个`字典`，其`键`和`值`是`函数`，然后使`字典双向`(`d[k] -> v, d[v] -> k`)。

```python
# 使字典双向(d[k] -> v, d[v] -> k)
def make_inverse(inverse_dict):
    for f in list(inverse_dict):
        inverse_dict[inverse_dict[f]] = f
    return inverse_dict


inverse = make_inverse({sin: asin, cos: acos, tan: atan, log: exp})
```

* 在 `Python` 中，`函数`是`普通对象`这一事实`通常`可以`这样说`：`函数是一等对象`、`函数是一等公民`。

## def 语句

* def 语句是定义函数的最常用方法。

```python
# def 语句的语法
def function_name(parameters):
    statement(s)
```

* `函数名`其实是一个`标识符`(`变量`)。当 `def 语句执行`时，这个`标识符`被`绑定`(或`重新绑定`)到对应的`函数对象`。

* 参数(`parameters`)是一个`可选`的`标识符列表`，这些标识符被`绑定`为`调用`函数时`提供的值`，将这些`值`也称为参数(`arguments`)。

* 为了`区分`定义参数(`parameters`)和调用参数(`arguments`)，parameters 称为`形参`，arguments 称为`实参`。

* 在最简单的情况下，一个函数`没有任何参数`，这意味着该函数在`调用时不接受任何参数`。在这种情况下，`函数的定义`也必须在`函数名之后`加上`空括号`，同理对函数的`调用也是如此`。

* 当函数确实`接受实参`时，`形参`包含`一个或多个标识符`，并用`逗号`(,)进行`分隔`。在这种情况下，对函数的`每次调用`都要`提供`与函数定义中列出的`形参`相`对应的`值(称为`实参`)。

* `形参`是`函数`的`局部变量`，并且每次`对函数的调用`都会将`函数的命名空间`中的这些`局部变量`绑定到`调用者提供的`或`函数定义时提供的`对应的`值`(称为`实参`)。

* `执行` `def 语句`时，`函数体`内的代码块`不`会`执行`。每次`调用函数`时，`函数体`内的代码块都会`执行`。

* `函数体`内可以出现`零个`或`多个` `return 语句`。

```python
# 实参可以是任何可以乘以 2 的值
# 可以使用数字，字符串，列表或元组等作为实参来调用 twice
# 在每种情况下，twice 都将返回与实参类型相同的新值
def twice(x):
    return x * 2
```

## 参数(parameters，形参)

* `形参`对`调用`函数时`传递的值`进行`命名`，有时还会为`形参`提供`默认值`。

* 每次`调用函数`时，每个`形参`都会被`绑定`在一个`新的局部命名空间`中。当`函数返回`或`以其他方式退出`时，此`命名空间`就会`被销毁`。当然，`调用者绑定函数的返回值`可以`使函数的返回值对象不被销毁`。

* `标识符`表示`位置参数`(也称为`强制参数`)。每次`对函数的调用`都`必须`为每个`位置`参数`提供`一个对应的`值`(`实参`)。

* 在逗号分隔的`参数列表`中，零个或多个`位置参数`后可以`跟`零个或多个`命名参数`(也称为`可选参数`，也称为`关键字参数`)

```python
# 命名参数，可选参数，关键字参数
def function_name(..., identifier=expression)
    pass
```

* `def 语句`会`求值`每个`命名参数`中的`表达式`，并在`函数对象的属性`中`保存`该`求值结果`的`引用`，这个值称为`参数默认值`。

* 当函数调用时`未提供`与`命名参数`相对应的`实参`时，该调用会`将该命名参数绑定到其默认值上`。

* 当 `def 语句执行`时，Python 会精确`计算一次`每个`默认值`，而`不是`在每次`调用函数时`求值默认值。这意味着，只要`调用者不提供`相应的`实际参数`，`命名参数`就将完全`使用相同`的`对象`(`默认值`)。

* `命名参数`使用`可变`的`默认值`时，需要特别`小心`。

* 在`不为命名参数`提供`实参`的情况下`调用函数`时，都`可以修改可变的默认值`(如列表)，这很`容易导致`不明原因的 `BUG`。

* 当`命名参数`的`默认值`为`可变对象`并且在`函数体修改了命名参数`(`可变默认值`)时，`事情`可能会很`棘手`。

```python
def f(x, y=[]):
    y.append(x)
    return y, id(y)
print(f(23)) # prints: ([23], 4302354376)
print(f(42)) # prints: ([23, 42], 4302354376)
# 每次使用单参数，调用 f 时，都会返回同一个 y 对象
```

```python
def f(x, y=None):
    if y is None: y = []
    y.append(x)
    return y, id(y)
print(f(23)) # prints: ([23], 4302354376)
prinf(f(42)) # prints: ([42], 4302180040)
# 每次使用单参数，调用 f 时，都会返回不同的 y 对象
```

* 有时，`明确`想要`修改命名参数的默认值`，`通常`这是出于`缓存目的`。

```python
def cached_compute(x, _cache={}):
    if x not in _cache:
        _cache[x] = costly_computation(x)
    return _cache[x]
```

* 通常`最好`还是通过`使用` `functools.lru_cache 装饰基础函数`来`获得`这种`缓存行为`(也称为 `memoization`)。

* 在`形参列表`的`最后`，可以`选择性`使用 `*args` 和 `**kwargs` 这两种`特殊形式`中的一种或两种。名称(`args`、`kwargs`)`没有特殊之处`，可以在每种`特殊形式`中`使用任何合法的标识符`；`args` 和 `kwargs` 只是这时的`常用标识符`而已。如果`同时存在`这`两种形式`的参数，则带有`两个星号的形式`必须排在`最后`。

* 指定 `*args` 形式的形参，会将调用中任何`未明确`指定的`位置参数`(额外的位置参数)`收集到`一个`元组对象`(可空，被绑定到 `args`)中。

* 指定 `**kwargs` 形式的参数，会将调用中任何`未明确`指定的`命名参数`(额外的命名参数)`收集到`一个`字典对象`(可空，被绑定到 `kwargs`)中，该词典的 `item` 是`名称字符串`(key)/`实参值`(value)对。

* 从 Python `3.6` 开始，`kwargs` 绑定到的`字典保留了`在调用中`传递`的额外的命名参数的`顺序`。这一点与`字典`的 `keys` 从 Python `3.6` 开始`有序`有关。

```python
# sum_args 函数可接受任意数量的位置参数，并返回他们的和
def sum_args(*args)
    return sum(args)
print(sum_args(23, 42)) # 65
```

### 函数签名

## 关键字参数

## 函数对象的属性

## 函数注解和类型提示

## return 语句

## 调用函数

## 命名空间

## lambda 表达式

## 生成器

## 递归
