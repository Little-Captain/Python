# 函数

* 典型的 `Python 程序`中的`大多数语句`都是`函数的一部分`。

* 将代码以`函数的形式`进行组织能使代码更具`条理性`和`可读性`。

* `函数体`中的代码`可能`比`模块顶层`的代码`快`。

* `函数`是`一组`在被`调用`时才`执行`的`语句`。

* Python 提供了许多`内置函数`，并`允许`程序员`定义`自己的`函数`。

* `请求执行函数`称为`函数调用`。

* `调用函数`时，可以通过`参数传递指定的数据`，函数在该数据上执行计算。

* 在 `Python` 中，`函数始终会返回一个结果值`(`没有显式返回任何值`，函数`默认`会`返回 None`)。

* 在 `class 语句`中定义的`函数`称为`方法`。对`函数`的`一般介绍`也`适用`于`方法`。

* 在 `Python` 中，`函数`是`对象`(`值`)，`要和其他对象同等对待`。

* 可以在调用另一个函数时将一个`函数作为参数`传递。同样，一个函数可以返回另一个`函数作为`调用的`返回值`。

* 和任何其他对象一样，`函数`可以`绑定到变量`，可以是`容器中的项`，也可以是`对象的属性`。

* 函数也可以是`字典中的键`。如果您需要`快速`找到给定`函数`的`逆函数`，则可以定义一个`字典`，其`键`和`值`是`函数`，然后使`字典双向`(`d[k] -> v, d[v] -> k`)。

```python
# 使字典双向(d[k] -> v, d[v] -> k)
def make_inverse(inverse_dict):
    for f in list(inverse_dict):
        inverse_dict[inverse_dict[f]] = f
    return inverse_dict


inverse = make_inverse({sin: asin, cos: acos, tan: atan, log: exp})
```

* 在 `Python` 中，`函数`是`普通对象`这一事实`通常`可以`这样说`：`函数是一等对象`、`函数是一等公民`。

## def 语句

* def 语句是定义函数的最常用方法。

```python
# def 语句的语法
def function_name(parameters):
    statement(s)
```

* `函数名`其实是一个`标识符`(`变量`)。当 `def 语句执行`时，这个`标识符`被`绑定`(或`重新绑定`)到对应的`函数对象`。

* 参数(`parameters`)是一个`可选`的`标识符列表`，这些标识符被`绑定`为`调用`函数时`提供的值`，将这些`值`也称为参数(`arguments`)。

* 为了`区分`定义参数(`parameters`)和调用参数(`arguments`)，parameters 称为`形参`，arguments 称为`实参`。

* 在最简单的情况下，一个函数`没有任何参数`，这意味着该函数在`调用时不接受任何参数`。在这种情况下，`函数的定义`也必须在`函数名之后`加上`空括号`，同理对函数的`调用也是如此`。

* 当函数确实`接受实参`时，`形参`包含`一个或多个标识符`，并用`逗号`(,)进行`分隔`。在这种情况下，对函数的`每次调用`都要`提供`与函数定义中列出的`形参`相`对应的`值(称为`实参`)。

* `形参`是`函数`的`局部变量`，并且每次`对函数的调用`都会将`函数的命名空间`中的这些`局部变量`绑定到`调用者提供的`或`函数定义时提供的`对应的`值`(称为`实参`)。

* `执行` `def 语句`时，`函数体`内的代码块`不`会`执行`。每次`调用函数`时，`函数体`内的代码块都会`执行`。

* `函数体`内可以出现`零个`或`多个` `return 语句`。

```python
# 实参可以是任何可以乘以 2 的值
# 可以使用数字，字符串，列表或元组等作为实参来调用 twice
# 在每种情况下，twice 都将返回与实参类型相同的新值
def twice(x):
    return x * 2
```

## 参数(parameters，形参)

* 参数类型分为：`位置`参数(`必选`参数)，`命名`参数，`元组`参数(`*`)，`字典`参数(`**`)

* `形参`对`调用`函数时`传递的值`进行`命名`，有时还会为`形参`提供`默认值`。

* 每次`调用函数`时，每个`形参`都会被`绑定`在一个`新的局部命名空间`中。当`函数返回`或`以其他方式退出`时，此`命名空间`就会`被销毁`。当然，`调用者绑定函数的返回值`可以`使函数的返回值对象不被销毁`。

* `标识符`表示`位置参数`(也称为`强制参数`)。每次`对函数的调用`都`必须`为每个`位置`参数`提供`一个对应的`值`(`实参`)。

* 在逗号分隔的`参数列表`中，零个或多个`位置参数`后可以`跟`零个或多个`命名参数`(也称为`可选参数`，也称为`关键字参数`)

```python
# 命名参数，可选参数，关键字参数
def function_name(..., identifier=expression)
    pass
```

* `def 语句`会`求值`每个`命名参数`中的`表达式`，并在`函数对象的属性`中`保存`该`求值结果`的`引用`，这个值称为`参数默认值`。

* 当函数调用时`未提供`与`命名参数`相对应的`实参`时，该调用会`将该命名参数绑定到其默认值上`。

* 当 `def 语句执行`时，Python 会精确`计算一次`每个`默认值`，而`不是`在每次`调用函数时`求值默认值。这意味着，只要`调用者不提供`相应的`实际参数`，`命名参数`就将完全`使用相同`的`对象`(`默认值`)。

* `命名参数`使用`可变`的`默认值`时，需要特别`小心`。

* 在`不为命名参数`提供`实参`的情况下`调用函数`时，都`可以修改可变的默认值`(如列表)，这很`容易导致`不明原因的 `BUG`。

* 当`命名参数`的`默认值`为`可变对象`并且在`函数体修改了命名参数`(`可变默认值`)时，`事情`可能会很`棘手`。

```python
def f(x, y=[]):
    y.append(x)
    return y, id(y)
print(f(23)) # prints: ([23], 4302354376)
print(f(42)) # prints: ([23, 42], 4302354376)
# 每次使用单参数，调用 f 时，都会返回同一个 y 对象
```

```python
def f(x, y=None):
    if y is None: y = []
    y.append(x)
    return y, id(y)
print(f(23)) # prints: ([23], 4302354376)
prinf(f(42)) # prints: ([42], 4302180040)
# 每次使用单参数，调用 f 时，都会返回不同的 y 对象
```

* 有时，`明确`想要`修改命名参数的默认值`，`通常`这是出于`缓存目的`。

```python
def cached_compute(x, _cache={}):
    if x not in _cache:
        _cache[x] = costly_computation(x)
    return _cache[x]
```

* 通常`最好`还是通过`使用` `functools.lru_cache 装饰基础函数`来`获得`这种`缓存行为`(也称为 `memoization`)。

* 在`形参列表`的`最后`，可以`选择性`使用 `*args` 和 `**kwargs` 这两种`特殊形式`中的一种或两种。名称(`args`、`kwargs`)`没有特殊之处`，可以在每种`特殊形式`中`使用任何合法的标识符`；`args` 和 `kwargs` 只是这时的`常用标识符`而已。如果`同时存在`这`两种形式`的参数，则带有`两个星号的形式`必须排在`最后`。

* 指定 `*args` 形式的形参，会将调用中任何`未明确`指定的`位置参数`(额外的位置参数)`收集到`一个`元组对象`(可空，被绑定到 `args`)中。

* 指定 `**kwargs` 形式的参数，会将调用中任何`未明确`指定的`命名参数`(额外的命名参数)`收集到`一个`字典对象`(可空，被绑定到 `kwargs`)中，该词典的 `item` 是`名称字符串`(key)/`实参值`(value)对。

* 从 Python `3.6` 开始，`kwargs` 绑定到的`字典保留了`在调用中`传递`的额外的命名参数的`顺序`。这一点与`字典`的 `keys` 从 Python `3.6` 开始`有序`有关。

```python
# sum_args 函数可接受任意数量的位置参数，并返回他们的和
def sum_args(*args)
    return sum(args)
print(sum_args(23, 42)) # 65
```

### 函数签名

* 函数的`参数数量`，以及`参数名称`，`位置参数的数量`，以及是否在参数列表末尾存在`单星号和双星号特殊形式`中的`一种还是两种`，`这些信息共同构成`了`函数签名`。`函数签名定义了调用函数的方式`。

## 强制关键字(Keyword-only)参数(仅 v3)

* 在 `v3` 中，一个 `def` 语句可以选择性地`指定`参数为`强制关键字参数`。在`调用函数`时，`必须`为强制关键字参数`传递`形如 `identifier=expression` 的`命名参数形式实参`。在 `*args`(没有，使用 \* 代表) 之`后`和 `**kwargs`(如果有) 之`前`的参数即为`强制关键字参数`。

* 第一种形式：强制关键字参数可以指定为`简单标识符形式`(这时，它是强制性的，在调用该函数时必须传递相应的命名参数)。

* 第二种形式：强制关键字参数可以指定为 `identifier=default 形式`(`命名参数形式`)(这时，它是可选的，调用该函数时不强制要求传递相应的参数。但是在传递该参数时，必须以命名参数的形式传递而不是位置参数)。

* 通常为了更易读，`简单标识符形式`在`前`，`命名参数形式`在`后`。

* 如果`存在`特殊形式参数 `*args`，则强制关键字参数序列必须在 `*args` 之后。

* 如果`不存在`特殊形式参数 `*args`，则强制关键字参数序列必须在 `*` 之后。`*` 用于`占位`，表示其后为强制关键字参数。

```python
def f(a, *, b, c=56):  # b 和 c 都是强制关键字参数
    return a, b, c

f(12, b=34)  # 返回 (12, 34, 56)。c 是可选的，因为它有默认值
f(12)  # 抛出一个 TypeError 异常。
# 异常消息是: missing 1 required keyword-only argument: 'b'
```

* 如果指定了特殊形式参数 `**kwargs`，则它必须位于`参数列表`的`最后`(`强制关键字参数`(如果有)之`后`）

```python
def g(x, *a, b=23, **kwargs):  # b 是强制关键字参数
    return x, a, b, kwargs

g(1, 2, 3, c=99)  # 返回 (1, (2, 3), 23, {'c': 99})
```

## 函数对象的属性

* `def 语句`设置了`函数对象`的`某些属性`。

* 属性 `__name__` 表示在 def 语句中作为`函数名`称给出的`标识符字符串`。`可以`将该属性`重新绑定`到任何`字符串值`，但是尝试`取消绑定`会`抛出异常`。

* `__defaults__` 属性指向`命名参数`(`不包括强制关键字参数`)的`默认值`组成的`元组对象`或`None`(`没有命名参数`)。该属性可以`重新绑定`或`取消绑定`。该属性只能指向 `None 对象` 和 `tuple 类型对象`。

### 文档字符串

* 另一个`函数属性`是`文档字符串`，也被称为 `docstring`。函数的文档字符串`被绑定`到函数对象的 `__doc__` 属性上。

* 如果`函数体`中的`第一条语句`是`字符串字面量`，则编译器会将`该字符串绑定到`函数的 `__doc__` 属性上。类似的规则`适用于类`(`类文档字符串`)和`模块`(`模块文档字符串`)。

* `文档字符串`通常`跨越多个物理行`，因此通常以`三引号字符串字面量形式`指定它们。

```python
def sum_args(*numbers):
    """Return the sum of multiple numerical arguments.

    The arguments are zero or more numbers.
    The result is their sum.
    """
    return sum(numbers)
```

* `文档字符串`应该是开发者编写的任何 Python `代码的一部分`。它们的`作用类似于注释`，但它们的`适用性更广`，因为它们在`运行时`仍然`可用`(`除非使用 python -OO 运行程序`)。

* 开发环境和工具可以使用`函数对象`，`类对象`和`模块对象`中的`文档字符串`来`提醒`程序员`如何使用这些对象`。

* `doctest` 模块可以轻松`检查文档字符串`中的`示例代码`是否正确。

* 为了使`文档字符串`尽可能有用，请`遵守`一些简单的`约定`：

  * 文档字符串的`第一行`应该是`函数用途`的`简明摘要`，以大写字母开头，以句点结尾。简明摘要`不应该提到函数名`，除非该名称碰巧是自然语言的单词，并且可以自然而然地出现在摘要中。
  
  * 如果文档字符串为多行，则`第二行`应为`空行`。
  
  * `随后`的几行应形成`一个`或`多个段落`，并用`空行分隔`。这些`段落`用以`描述`函数的`参数`，`前提条件`，`返回值`和`副作用`(如果有)。
  
  * `进一步的解释`，`参考书目`和`用法示例`(应使用 `doctest` 模块`检查正确性`)可以选择添加在`文档字符串`的`末尾`。

### 函数对象的其他属性

* 除了函数对象的预定义属性外，`函数对象`还`可以具有`其他`任意属性`。

* 要创建函数对象的属性，请在 `def 语句执行后`，将`值`通过`赋值语句`绑定到`相应的属性`引用`上`。

* 请注意，这`不`是`常规`用法。通常，当要将某些`状态`(`data`)和某些`行为`(`code`)`组合`在一起时，`应该使用面向对象`的机制。

* 但是，`有时`使用`这一技术`(可以将任意属性与函数对象关联起来)能够`带来一些便利`。

```python
# 对自身被调用次数进行计数
def counter():
    counter.count += 1
    return counter.count
counter.count = 0
```

## 函数注解和类型提示(仅 v3)

* `仅`在 `v3` 中，可以使用`任意表达式`对 def 语句中的`每个参数`进行`注解`。

* 也就是说，在 def 的`参数列表`中可以使用 `identifier` 的`任何地方`，都可以`换作` `identifier:expression` 的形式，并且 `expression 的值`成为 `identifier 参数名`的`注解`。

* 可以在def 语句的 `)` 和 `:` 之间使用 `->expression` 的形式来`注解`函数的`返回值`。`expression 的值`成为`名称 "return"` 的`注解`。

```python
def f(a:'foo', b) ->'bar':
    pass

print(f.__annotations__) # {'a': 'foo', 'return': 'bar'}
```

* `函数对象`的 `__annotations__` 属性是一个`字典对象`，它`保存`一些列`键值对` key/value。`key`：被注解的标识符(`identifier`)`字符串`；`value`：注解表达式(`expression`)的`求值结果`。

* 可以将`注解`用于`任何目的`：`Python` 对它们`除了构造 __annotations__ 属性外`，`不执行任何操作`。

* `注解的目的`是让`未来的假设性第三方工具`利用`注释`对有注解的函数执行`更彻底`的`静态检查`(如果想`尝试`这种静态检查，建议尝试 `mypy 项目`)。

### 类型提示(Python 3.5 及以上)

* 为了进一步`支持`未来的假设性`第三方工具`，`Python 3.5` 引入了一组`复杂`的`注释约定`，并在`标准库`中`引入`了一个`新的临时模块`，称为 `typing`，以`标准化`如何使用注解来表示`类型提示`(同样，`Python 不会`使用这些信息`执行任何操作`，但`第三方工具`可能`会`利用这种现在已经标准化的信息做一些操作。

A provisional module is one that might change drastically, or even disappear, as early as the next feature release (so, in the future, Python 3.7 might not have the module typing in its standard library, or the module’s contents might be different). It is not yet intended for use “in production,” but rather just for experimental purposes.

* 

### 类型注解(Python 3.6 及以上)

## return 语句

## 调用函数

## 命名空间

## lambda 表达式

## 生成器

## 递归
