# 函数

* 典型的 `Python 程序`中的`大多数语句`都是`函数的一部分`。

* 将代码以`函数的形式`进行组织能使代码更具`条理性`和`可读性`。

* `函数体`中的代码`可能`比`模块顶层`的代码`快`。

* `函数`是`一组`在被`调用`时才`执行`的`语句`。

* Python 提供了许多`内置函数`，并`允许`程序员`定义`自己的`函数`。

* `请求执行函数`称为`函数调用`。

* `调用函数`时，可以通过`参数传递指定的数据`，函数在该数据上执行计算。

* 在 `Python` 中，`函数始终会返回一个结果值`(`没有显式返回任何值`，函数`默认`会`返回 None`)。

* 在 `class 语句`中定义的`函数`称为`方法`。对`函数`的`一般介绍`也`适用`于`方法`。

* 在 `Python` 中，`函数`是`对象`(`值`)，`要和其他对象同等对待`。

* 可以在调用另一个函数时将一个`函数作为参数`传递。同样，一个函数可以返回另一个`函数作为`调用的`返回值`。

* 和任何其他对象一样，`函数`可以`绑定到变量`，可以是`容器中的项`，也可以是`对象的属性`。

* 函数也可以是`字典中的键`。如果您需要`快速`找到给定`函数`的`逆函数`，则可以定义一个`字典`，其`键`和`值`是`函数`，然后使`字典双向`(`d[k] -> v, d[v] -> k`)。

```python
# 使字典双向(d[k] -> v, d[v] -> k)
def make_inverse(inverse_dict):
    for f in list(inverse_dict):
        inverse_dict[inverse_dict[f]] = f
    return inverse_dict


inverse = make_inverse({sin: asin, cos: acos, tan: atan, log: exp})
```

* 在 `Python` 中，`函数`是`普通对象`这一事实`通常`可以`这样说`：`函数是一等对象`、`函数是一等公民`。

## def 语句

* def 语句是定义函数的最常用方法。

```python
# def 语句的语法
def function_name(parameters):
    statement(s)
```

* `函数名`其实是一个`标识符`(`变量`)。当 `def 语句执行`时，这个`标识符`被`绑定`(或`重新绑定`)到对应的`函数对象`。

* 参数(`parameters`)是一个`可选`的`标识符列表`，这些标识符被`绑定`为`调用`函数时`提供的值`，将这些`值`也称为参数(`arguments`)。

* 为了`区分`定义参数(`parameters`)和调用参数(`arguments`)，parameters 称为`形参`，arguments 称为`实参`。

* 在最简单的情况下，一个函数`没有任何参数`，这意味着该函数在`调用时不接受任何参数`。在这种情况下，`函数的定义`也必须在`函数名之后`加上`空括号`，同理对函数的`调用也是如此`。

* 当函数确实`接受实参`时，`形参`包含`一个或多个标识符`，并用`逗号`(,)进行`分隔`。在这种情况下，对函数的`每次调用`都要`提供`与函数定义中列出的`形参`相`对应的`值(称为`实参`)。

* `形参`是`函数`的`局部变量`，并且每次`对函数的调用`都会将`函数的命名空间`中的这些`局部变量`绑定到`调用者提供的`或`函数定义时提供的`对应的`值`(称为`实参`)。

* `执行` `def 语句`时，`函数体`内的代码块`不`会`执行`。每次`调用函数`时，`函数体`内的代码块都会`执行`。

* `函数体`内可以出现`零个`或`多个` `return 语句`。

```python
# 实参可以是任何可以乘以 2 的值
# 可以使用数字，字符串，列表或元组等作为实参来调用 twice
# 在每种情况下，twice 都将返回与实参类型相同的新值
def twice(x):
    return x * 2
```

## 参数(parameters，形参)

* 参数类型分为：`位置`参数(`必选`参数)，`命名`参数，`元组`参数(`*`)，`字典`参数(`**`)

* `形参`对`调用`函数时`传递的值`进行`命名`，有时还会为`形参`提供`默认值`。

* 每次`调用函数`时，每个`形参`都会被`绑定`在一个`新的局部命名空间`中。当`函数返回`或`以其他方式退出`时，此`命名空间`就会`被销毁`。当然，`调用者绑定函数的返回值`可以`使函数的返回值对象不被销毁`。

* `标识符`表示`位置参数`(也称为`强制参数`)。每次`对函数的调用`都`必须`为每个`位置`参数`提供`一个对应的`值`(`实参`)。

* 在逗号分隔的`参数列表`中，零个或多个`位置参数`后可以`跟`零个或多个`命名参数`(也称为`可选参数`，也称为`关键字参数`)

```python
# 命名参数，可选参数，关键字参数
def function_name(..., identifier=expression)
    pass
```

* `def 语句`会`求值`每个`命名参数`中的`表达式`，并在`函数对象的属性`中`保存`该`求值结果`的`引用`，这个值称为`参数默认值`。

* 当函数调用时`未提供`与`命名参数`相对应的`实参`时，该调用会`将该命名参数绑定到其默认值上`。

* 当 `def 语句执行`时，Python 会精确`计算一次`每个`默认值`，而`不是`在每次`调用函数时`求值默认值。这意味着，只要`调用者不提供`相应的`实际参数`，`命名参数`就将完全`使用相同`的`对象`(`默认值`)。

* `命名参数`使用`可变`的`默认值`时，需要特别`小心`。

* 在`不为命名参数`提供`实参`的情况下`调用函数`时，都`可以修改可变的默认值`(如列表)，这很`容易导致`不明原因的 `BUG`。

* 当`命名参数`的`默认值`为`可变对象`并且在`函数体修改了命名参数`(`可变默认值`)时，`事情`可能会很`棘手`。

```python
def f(x, y=[]):
    y.append(x)
    return y, id(y)
print(f(23)) # prints: ([23], 4302354376)
print(f(42)) # prints: ([23, 42], 4302354376)
# 每次使用单参数，调用 f 时，都会返回同一个 y 对象
```

```python
def f(x, y=None):
    if y is None: y = []
    y.append(x)
    return y, id(y)
print(f(23)) # prints: ([23], 4302354376)
prinf(f(42)) # prints: ([42], 4302180040)
# 每次使用单参数，调用 f 时，都会返回不同的 y 对象
```

* 有时，`明确`想要`修改命名参数的默认值`，`通常`这是出于`缓存目的`。

```python
def cached_compute(x, _cache={}):
    if x not in _cache:
        _cache[x] = costly_computation(x)
    return _cache[x]
```

* 通常`最好`还是通过`使用` `functools.lru_cache 装饰基础函数`来`获得`这种`缓存行为`(也称为 `memoization`)。

* 在`形参列表`的`最后`，可以`选择性`使用 `*args` 和 `**kwargs` 这两种`特殊形式`中的一种或两种。名称(`args`、`kwargs`)`没有特殊之处`，可以在每种`特殊形式`中`使用任何合法的标识符`；`args` 和 `kwargs` 只是这时的`常用标识符`而已。如果`同时存在`这`两种形式`的参数，则带有`两个星号的形式`必须排在`最后`。

* 指定 `*args` 形式的形参，会将调用中任何`未明确`指定的`位置参数`(额外的位置参数)`收集到`一个`元组对象`(可空，被绑定到 `args`)中。

* 指定 `**kwargs` 形式的参数，会将调用中任何`未明确`指定的`命名参数`(额外的命名参数)`收集到`一个`字典对象`(可空，被绑定到 `kwargs`)中，该词典的 `item` 是`名称字符串`(key)/`实参值`(value)对。

* 从 Python `3.6` 开始，`kwargs` 绑定到的`字典保留了`在调用中`传递`的额外的命名参数的`顺序`。这一点与`字典`的 `keys` 从 Python `3.6` 开始`有序`有关。

```python
# sum_args 函数可接受任意数量的位置参数，并返回他们的和
def sum_args(*args)
    return sum(args)
print(sum_args(23, 42)) # 65
```

### 函数签名

* 函数的`参数数量`，以及`参数名称`，`位置参数的数量`，以及是否在参数列表末尾存在`单星号和双星号特殊形式`中的`一种还是两种`，`这些信息共同构成`了`函数签名`。`函数签名定义了调用函数的方式`。

## 强制关键字(Keyword-only)参数(仅 v3)

* 在 `v3` 中，一个 `def` 语句可以选择性地`指定`参数为`强制关键字参数`。在`调用函数`时，`必须`为强制关键字参数`传递`形如 `identifier=expression` 的`命名参数形式实参`。在 `*args`(没有，使用 \* 代表) 之`后`和 `**kwargs`(如果有) 之`前`的参数即为`强制关键字参数`。

* 第一种形式：强制关键字参数可以指定为`简单标识符形式`(这时，它是强制性的，在调用该函数时必须传递相应的命名参数)。

* 第二种形式：强制关键字参数可以指定为 `identifier=default 形式`(`命名参数形式`)(这时，它是可选的，调用该函数时不强制要求传递相应的参数。但是在传递该参数时，必须以命名参数的形式传递而不是位置参数)。

* 通常为了更易读，`简单标识符形式`在`前`，`命名参数形式`在`后`。

* 如果`存在`特殊形式参数 `*args`，则强制关键字参数序列必须在 `*args` 之后。

* 如果`不存在`特殊形式参数 `*args`，则强制关键字参数序列必须在 `*` 之后。`*` 用于`占位`，表示其后为强制关键字参数。

```python
def f(a, *, b, c=56):  # b 和 c 都是强制关键字参数
    return a, b, c

f(12, b=34)  # 返回 (12, 34, 56)。c 是可选的，因为它有默认值
f(12)  # 抛出一个 TypeError 异常。
# 异常消息是: missing 1 required keyword-only argument: 'b'
```

* 如果指定了特殊形式参数 `**kwargs`，则它必须位于`参数列表`的`最后`(`强制关键字参数`(如果有)之`后`）

```python
def g(x, *a, b=23, **kwargs):  # b 是强制关键字参数
    return x, a, b, kwargs

g(1, 2, 3, c=99)  # 返回 (1, (2, 3), 23, {'c': 99})
```

## 函数对象的属性

* `def 语句`设置了`函数对象`的`某些属性`。

* 属性 `__name__` 表示在 def 语句中作为`函数名`称给出的`标识符字符串`。`可以`将该属性`重新绑定`到任何`字符串值`，但是尝试`取消绑定`会`抛出异常`。

* `__defaults__` 属性指向`命名参数`(`不包括强制关键字参数`)的`默认值`组成的`元组对象`或`None`(`没有命名参数`)。该属性可以`重新绑定`或`取消绑定`。该属性只能指向 `None 对象` 和 `tuple 类型对象`。

### 文档字符串

Another function attribute is the documentation string, also known as the docstring. You may use or rebind a function’s docstring attribute as __doc__. If the first state‐ ment in the function body is a string literal, the compiler binds that string as the function’s docstring attribute. A similar rule applies to classes (see “Class documen‐ tation strings” on page 103) and modules (see “Module documentation strings” on page 174). Docstrings usually span multiple physical lines, so you normally specify them in triple-quoted string literal form.

* 

## 函数注解和类型提示

## return 语句

## 调用函数

## 命名空间

## lambda 表达式

## 生成器

## 递归
