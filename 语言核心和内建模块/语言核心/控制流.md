# 控制流

* 程序的`控制流`是程序`代码`执行的`顺序`。

* Python 程序的`控制流`包括`条件语句`，`循环语句`和`函数调用`。

* `抛出异常`和`处理异常`会`影响控制流`。

## if 语句

* 通常，仅在`满足`某些`条件`时才需要`执行`某些`语句`，或者`根据`互斥`条件`选择要`执行`的`语句`。`复合 if 语句`(包含 `if`，`elif` 和 `else` 子句) 可以有条件地`执行`满足条件的`语句块`。

```python
# if 语句的语法
if expression:
    statement(s)
elif expression:
    statement(s)
elif expression:
    statement(s)
...
else:
    statement(s)
```

* `elif` 和 `else` 子句是`可选的`。

* Python `没有` `switch` 语句。`if`，`elif` 和 `else` 用于`所有`的`条件处理`。

```python
# 一个典型的 if 语句
if x < 0:
    print('x is negative')
elif x % 2:
    print('x is positive and odd')
else:
    print('x is even and non-negative')
```

* 在 Python 中，使用`四空格`进行代码`缩进`的样式更`通用`，更`易读`，并且被 `PEP 8` 推荐。

* 可以在 `if` 或 `elif` 子句中`使用`任何 Python `表达式`作为`条件`。以这种方式使用一个表达式称为`在布尔上下文中使用表达式`。在布尔上下文中，`任何值`均会被`求值`(`与调用 bool(value) 的结果一致`)为 `True` 或 `False`。

* 在`布尔上下文`中，任何`非零`数字或`非空`容器(字符串，元组，列表，字典，集合)的`求值`结果为 `True`；`零`(任何数字类型)，`None` 和`空`容器的`求值`结果为 `False`。

* 简洁且更 Python 的风格：`if x:`；不推荐使用的风格：`if x is True:` `if x == True:` `if bool(x):`。

* 一个表达式`返回` `True`，意味着该表达式`返回布尔类型的值 1`。

* 一个表达式的`求值`结果为 `True`，意味着该表达式在`布尔上下文`中的`求值结果为 True`。

* `测试`一个`表达式`的`真假`时(如，在 if 子句中)，我们`关心`的`是`它的`求值结果`，而`不是`它的`返回结果`。

* if 语句的`执行流程`：如果 `if` 子句的`条件求值`为 `True`，则`执行` if 子句`之后`的`语句`，然后整个 `if 语句结束`。`否则`，Python 会`按顺序求值`每个 `elif` 子句的`条件`。当第一个 elif 子句(如果有)的`条件求值`为 `True` 时，`之后`的`语句`将`被执行`，然后整个 `if 语句结束`。`否则`，当 `else 子句存在`时，将`执行该语句`，然后整个 `if 语句结束`。

## while 语句

* `while` 语句用于`重复执行`由`条件表达式控制`的`语句`或`语句块`。

```python
# while 语句的语法
while expression:
    statement(s)
```

* `while` 语句可以包含 `else` 子句以及 `break` 语句和 `continue` 语句。

```python
# 典型的 while 语句
count = 0
while x > 0:
    x //= 2
    count += 1
print('The approximate log2 is', count)
```

* 首先，Python `求值`作为`循环条件`的表达式。如果条件为`假`，则 `while 语句结束`。当循环条件为`真`时，`执行循环体`中的一个或多个语句。循环体`执行完一次`后，Python 将`再次求值循环条件`，以检查`是否`应执行`下一次迭代`。该过程`一直持续到循环条件为假`为止，此时 `while 语句结束`。

* `循环体`应`包含`最终使`循环条件`为`假`的`代码`；`否`则，`循环`永远`不会结束`(`除非`循环体内`抛出异常`或`执行 break 语句`)。如果`循环体内执行 return 语句`，则`函数体中的循环也会结束`，因为`这时`，`整个函数都会结束`。

## for 语句

* `for` 语句`重复执行`由`可迭代表达式控制`的`语句`或`语句块`。

```python
# for 语句语法
for target in iterable:
    statement(s)
```

* `in` 关键字是 `for` 语句`语法`的`一部分`；它在这里的`目的不同于`进行`关系测试`的 `in` 运算符。

```python
# 典型的 for 语句
for letter in 'ciao':
    print('give me a', letter, '...')
```

* `for` 语句可以包含 `else` 子句以及 `break` 语句和 `continue` 语句。

* 在 `for` 语句语法中，`iterable` 是可以作为`内置函数 iter`(该函数`返回`迭代器对象) 的`参数`的任何 Python `表达式`。特别地，任何`序列`都是 `iterable`。

* 在 `for` 语句语法中，`target` 通常是`一个标识符`，它`为循环的控制变量命名`；for 语句`依次`将这个`变量`重新`绑定为`迭代器的每个`项`。

* 在 `for` 语句语法中，`循环体`(一个或多个语句)对于 `iterable` 的`每个 item 执行一次`(`除非`循环由于`异常`或 `break` 语句或 `return` 语句而终止)。

* 可以使用带有`多个标识符`的 `target`，这时和`拆箱赋值类似`。这时，`迭代器的项`必须是`可迭代对象`，`迭代器的项`(可迭代对象)所拥有的`项`的`数量`与 `target` 中存在的`标识符`的`数量`需要`一样多`(仅在 `v3` 中，其中`某个标识符`可以`加星`号，`加星标识符`被`绑定为`所有`未分配`给`其他标识符`的`项`所`组成`的`列表`，所以`加星标识符`引用的对象是一个`列表`)。

```python
# d 是一个字典。使用 for 循环遍历字典中的键值对
for key, value in d.items():
    if key and value:
        print(key, value)
```

* `字典对象`的 `items 方法`返回以`键值对`为`元素`的`可迭代对象`(在 `v2` 中是`列表`；在 `v3` 中是类型为 `dict_items` 的`可迭代对象`)，因此使用 `target` 中带有`两个标识符`的 `for 循环`来将每个`项`(`键值对`)`解包`到 `key` 和 `value`。尽管 `target` 的组成部分`通常`是`标识符`，但`值`可以`绑定到`任何`合法`的 `LHS 表达式`上。

```python
prototype = [1, 'placemarker', 3]
for prototype[1] in 'xyz':
    # prints [1, 'x', 3], then [1, 'y', 3], then [1, 'z', 3]
    print(prototype)
```

* `循环`时`不`要`修改可变对象`。

* 当`可迭代对象`具有`可变`的`基础对象`(`项`，`元素`)时，`请勿`在对其进行 `for 循环期间`更`改`其`基础对象`。

* `v2` 中的 `iteritems` 方法以及 `v3` 中的 `items` 方法返回`基于字典对象`的`可迭代对象`，因此循环体内`无法更改字典中`的`键`。

* `v2` 中的 `d.items()` 以及 `v3` 中的 `list(d.items())` 返回`新`的`独立列表`，因此，循环体`不可能修改 d`。

* 在`列表`上循环时，请勿`插入`，`追加`或`删除`项(在现有索引处`重新绑定项`是`可以`的)。

* 在`字典`上循环时，请勿`添加`或`删除`项(`重新绑定现有键的值`是`可以`的)。

* 在 `set` 上循环时，请勿`添加`或`删除`项(`不允许更改`)。

The control target variable(s) may be rebound in the loop body, but get rebound again to the next item in the iterator at the next iteration of the loop. The loop body does not execute at all if the iterator yields no items. In this case, the control variable is not bound or rebound in any way by the for statement. However, if the iterator yields at least one item, then, when the loop statement terminates, the control variable remains bound to the last value to which the loop statement has bound it. The following code is therefore correct only when someseq is not empty:

```python
for x in someseq:
    process(x)
print('Last item processed was', x)
```

## break 语句

## continue 语句

## 循环语句中的 else 子句

## pass 语句

## try 语句和 raise 语句

## with 语句
