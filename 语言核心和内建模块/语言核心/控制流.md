# 控制流

* 程序的`控制流`是程序`代码`执行的`顺序`。

* Python 程序的`控制流`包括`条件语句`，`循环语句`和`函数调用`。

* `抛出异常`和`处理异常`会`影响控制流`。

## if 语句

* 通常，仅在`满足`某些`条件`时才需要`执行`某些`语句`，或者`根据`互斥`条件`选择要`执行`的`语句`。`复合 if 语句`(包含 `if`，`elif` 和 `else` 子句) 可以有条件地`执行`满足条件的`语句块`。

```python
# if 语句的语法
if expression:
    statement(s)
elif expression:
    statement(s)
elif expression:
    statement(s)
...
else:
    statement(s)
```

* `elif` 和 `else` 子句是`可选的`。

* Python `没有` `switch` 语句。`if`，`elif` 和 `else` 用于`所有`的`条件处理`。

```python
# 一个典型的 if 语句
if x < 0:
    print('x is negative')
elif x % 2:
    print('x is positive and odd')
else:
    print('x is even and non-negative')
```

* 在 Python 中，使用`四空格`进行代码`缩进`的样式更`通用`，更`易读`，并且被 `PEP 8` 推荐。

* 可以在 `if` 或 `elif` 子句中`使用`任何 Python `表达式`作为`条件`。以这种方式使用一个表达式称为`在布尔上下文中使用表达式`。在布尔上下文中，`任何值`均会被`求值`(`与调用 bool(value) 的结果一致`)为 `True` 或 `False`。

* 在`布尔上下文`中，任何`非零`数字或`非空`容器(字符串，元组，列表，字典，集合)的`求值`结果为 `True`；`零`(任何数字类型)，`None` 和`空`容器的`求值`结果为 `False`。

* 简洁且更 Python 的风格：`if x:`；不推荐使用的风格：`if x is True:` `if x == True:` `if bool(x):`。

* 一个表达式`返回` `True`，意味着该表达式`返回布尔类型的值 1`。

* 一个表达式的`求值`结果为 `True`，意味着该表达式在`布尔上下文`中的`求值结果为 True`。

* `测试`一个`表达式`的`真假`时(如，在 if 子句中)，我们`关心`的`是`它的`求值结果`，而`不是`它的`返回结果`。

* if 语句的`执行流程`：如果 `if` 子句的`条件求值`为 `True`，则`执行` if 子句`之后`的`语句`，然后整个 `if 语句结束`。`否则`，Python 会`按顺序求值`每个 `elif` 子句的`条件`。当第一个 elif 子句(如果有)的`条件求值`为 `True` 时，`之后`的`语句`将`被执行`，然后整个 `if 语句结束`。`否则`，当 `else 子句存在`时，将`执行该语句`，然后整个 `if 语句结束`。

## while 语句

* `while` 语句用于`重复执行`由`条件表达式控制`的`语句`或`语句块`。

```python
# while 语句的语法
while expression:
    statement(s)
```

* `while` 语句可以包含 `else` 子句以及 `break` 语句和 `continue` 语句。

```python
# 典型的 while 语句
count = 0
while x > 0:
    x //= 2
    count += 1
print('The approximate log2 is', count)
```

* 首先，Python `求值`作为`循环条件`的表达式。如果条件为`假`，则 `while 语句结束`。当循环条件为`真`时，`执行循环体`中的一个或多个语句。循环体`执行完一次`后，Python 将`再次求值循环条件`，以检查`是否`应执行`下一次迭代`。该过程`一直持续到循环条件为假`为止，此时 `while 语句结束`。

* `循环体`应`包含`最终使`循环条件`为`假`的`代码`；`否`则，`循环`永远`不会结束`(`除非`循环体内`抛出异常`或`执行 break 语句`)。如果`循环体内执行 return 语句`，则`函数体中的循环也会结束`，因为`这时`，`整个函数都会结束`。

## for 语句

* `for` 语句`重复执行`由`可迭代表达式控制`的`语句`或`语句块`。

```python
# for 语句语法
for target in iterable:
    statement(s)
```

* `in` 关键字是 `for` 语句`语法`的`一部分`；它在这里的`目的不同于`进行`关系测试`的 `in` 运算符。

```python
# 典型的 for 语句
for letter in 'ciao':
    print('give me a', letter, '...')
```

* `for` 语句可以包含 `else` 子句以及 `break` 语句和 `continue` 语句。

* 在 `for` 语句语法中，`iterable` 是可以作为`内置函数 iter`(该函数`返回`迭代器对象) 的`参数`的任何 Python `表达式`。特别地，任何`序列`都是 `iterable`。

* 在 `for` 语句语法中，`target` 通常是`一个标识符`，它`为循环的控制变量命名`；for 语句`依次`将这个`变量`重新`绑定为`迭代器的每个`项`。

* 在 `for` 语句语法中，`循环体`(一个或多个语句)对于 `iterable` 的`每个 item 执行一次`(`除非`循环由于`异常`或 `break` 语句或 `return` 语句而终止)。

* 可以使用带有`多个标识符`的 `target`，这时和`拆箱赋值类似`。这时，`迭代器的项`必须是`可迭代对象`，`迭代器的项`(可迭代对象)所拥有的`项`的`数量`与 `target` 中存在的`标识符`的`数量`需要`一样多`(仅在 `v3` 中，其中`某个标识符`可以`加星`号，`加星标识符`被`绑定为`所有`未分配`给`其他标识符`的`项`所`组成`的`列表`，所以`加星标识符`引用的对象是一个`列表`)。

```python
# d 是一个字典。使用 for 循环遍历字典中的键值对
for key, value in d.items():
    if key and value:
        print(key, value)
```

* `字典对象`的 `items 方法`返回以`键值对`为`元素`的`可迭代对象`(在 `v2` 中是`列表`；在 `v3` 中是类型为 `dict_items` 的`可迭代对象`)，因此使用 `target` 中带有`两个标识符`的 `for 循环`来将每个`项`(`键值对`)`解包`到 `key` 和 `value`。尽管 `target` 的组成部分`通常`是`标识符`，但`值`可以`绑定到`任何`合法`的 `LHS 表达式`上。

```python
prototype = [1, 'placemarker', 3]
for prototype[1] in 'xyz':
    # prints [1, 'x', 3], then [1, 'y', 3], then [1, 'z', 3]
    print(prototype)
```

* `循环`时`不`要`修改可变对象`。

* 当`可迭代对象`具有`可变`的`基础对象`(`项`，`元素`)时，`请勿`在对其进行 `for 循环期间`更`改`其`基础对象`。

* `v2` 中的 `iteritems` 方法以及 `v3` 中的 `items` 方法返回`基于字典对象`的`可迭代对象`，因此循环体内`无法更改字典中`的`键`。

* `v2` 中的 `d.items()` 以及 `v3` 中的 `list(d.items())` 返回`新`的`独立列表`，因此，循环体`不可能修改 d`。

* 在`列表`上循环时，请勿`插入`，`追加`或`删除`项(在现有索引处`重新绑定项`是`可以`的)。

* 在`字典`上循环时，请勿`添加`或`删除`项(`重新绑定现有键的值`是`可以`的)。

* 在 `set` 上循环时，请勿`添加`或`删除`项(`不允许更改`)。

* `for` 循环的 `target 标识符`可以在`循环体`中被`重新绑定`，但是在循环的`下一次迭代`时 `target 标识符`会再次`重新绑定`到`迭代器`中的`下一项`。

* 如果`迭代器不产生任何项`，则`循环体根本不会执行`。这时，`for` 语句`不会`以任何方式`绑定`或`重新绑定` `target 标识符`(`for` 语句`后`的代码，`不能使用` `target 标识符`)。

* 如果`迭代器`产生`至少一项`，则在`循环语句结束`后，`target 标识符`仍将`绑定`到的`迭代器`发出的`最后一个值`。

```python
# 仅当 someseq 不为空时，以下代码才是正确的
for x in someseq:
    process(x)
print('Last item processed was', x)
```

### 迭代器

* `迭代器`是一个`对象 i`，可以`调用 next(i)`。next(i) `返回`迭代器 i 的`下一项`，或者，当迭代器 i `没有更多项`时，`抛出 StopIteration 异常`。

* 也可以`调用 next(i，default)`，在这种情况下，当迭代器 i `没有更多项`时，该调用将`返回 default`。

* 编写`类`时，可以通过定义`特殊方法` `__next__`(在 `v2` 中，该方法名为 `next`，这是被认为是`设计错误`) 来使其成为`迭代器`，该方法`除 self 参数` 外`不带任何参数`，并`返回下一项`或`抛出 StopIteration 异常`。

* `大多数迭代器`是通过`对内置函数 iter` 的`隐式或显式调用构建`的。`调用`一个`生成器`也会`返回`一个`迭代器`。

* `for` 语句`隐式`调用 `iter` 来获得`迭代器`。

```python
for x in c:
    statement(s)
# 等价于
_temporary_iterator = iter(c)
while True:
    try:
        x = next(_temporary_iterator)
    except StopIteration:
        break
    statement(s)
```

* 当 `iter(c)` 返回一个`迭代器 i`，`next(i)` 永远`不`会`抛出 StopIteration 异常`时，`i` 是一个`无界迭代器`，循环语句 `for x in c` 也`永远不会终止`(除非`循环体`中的语句包括 `break` 语句或 `return` 语句，或`抛出异常`，或`传播异常`)。

* `iter(c)` 调用特殊方法 `c.__iter__()` 来`获取`并返回 `c` 上的`迭代器`。

* 在`标准库模块 itertools` 中，可以找到许多`构建`和`操作迭代器`的`最佳方法`。

### range 和 xrange

* `遍历`一个`整数序列`是一项`常见`的`任务`。因此，Python 提供了`内置函数 range`(在 `v2` 中为 `xrange`。在 `v2` 中也有 `内置函数 range`，它`返回`一个`列表`) 来`生成整数序列`。

```python
# Python 中最简单的循环 n 次的方法
for i in range(n):
    statement(s)
```

* 在 `v2` 中，`range(x)` 返回一个`列表`，该列表的项是从 `0(包含)` 到 `x(不包含)` 的连续整数。

* `range(x, y)` 返回一个列表，该列表的项是从 `x(包含)` 到 `y(不包含)` 的连续整数。当 `x 大于或等于 y` 时，结果为`空列表`。

* `range(x, y, stride)` 返回一个从 `x(包含)` 到 `y(不包含)` 的整数列表(相邻两个`项`之间的`差`为 `stride`)。

* 如果 `stride < 0`，则 range `从 x 到 y 递减`。

* 当 `x >= y` 并且 `stride > 0` 时，或者当 `x <= y` 并且 `stride < 0` 时，range 返回`空列表`。

* 当 `stride == 0` 时，range 将`抛出异常`。

* 在 `v2` 中，`range` 返回可用于任何目的的`普通列表对象`，而 `xrange` 返回一个`专用对象`，该对象`仅用于迭代`(如 for 语句)。

* `xrange` 本身`不返回迭代器`；但是，如果`需要`，可以通过`调用 iter(xrange(...)))` 轻松`获得`这样的迭代器。

* `xrange` 返回的`专用对象`比 `range` 返回的`列表对象`消耗的`内存更少`。除了更节约内存外，可以在`任何可以使用 xrange 的地方使用 range`，但`反之`则`不行`。

```python
# 在 v2 中
print(range(1, 5)) # 输出 [1, 2, 3, 4]
print(xrange(1, 5)) # 输出 xrange(1, 5)
```

* 在 `v2` 中，`range` `返回`一个非常普通的`列表对象`，但是 `xrange` `返回`一个`用于特殊目的的对象`(`专用对象`)。

* 在 `v3` 中，`没有 xrange 函数`，而 `v3` 中的 `range` 与 `v2` 的 `xrange` `类似`。在 `v3` 中，如果`需要`一个类似 `v2` 中 `range` 函数`返回`的`列表对象`，可以`调用 list(range(...))` 得到。

### 元组生成式

```python
(i for i in range(12)) # 创建一个生成器 <generator object <genexpr> at ...>
# 使用元组生成式创建元组。将生成器转换为元组
tuple(i for i in range(12)) # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
```

### 列表生成式

A common use of a for loop is to inspect each item in an iterable and build a new list by appending the results of an expression computed on some or all of the items. The expression form known as a list comprehension or listcomp lets you code this common idiom concisely and directly. Since a list comprehension is an expression (rather than a block of statements), you can use it wherever you need an expression (e.g., as an argument in a function call, in a return statement, or as a subexpression of some other expression).

* for循环的常见用法是检查可迭代项中的每个项目，并通过将对部分或全部项目计算出的表达式的结果附加到列表中来构建新列表。 称为列表理解或listcomp的表达式形式使您可以简洁，直接地编写此常用习语。 由于列表推导是一个表达式（而不是语句块），因此可以在需要表达式的任何地方使用它（例如，用作函数调用中的参数，返回语句中或其他表达式的子表达式）。

### Set 生成式

### 字典生成式

## break 语句

## continue 语句

## 循环语句中的 else 子句

## pass 语句

## try 语句和 raise 语句

## with 语句
