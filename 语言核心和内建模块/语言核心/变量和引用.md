# 变量和引用

* Python 程序通过`引用访问数据值`。

* `引用`是指引用值(`对象`)的"`名称`"。

* 引用采用`变量`(variables)，`属性`(attributes)和`项`(items)的形式。

* 在 Python 中，`变量或其他引用没有内部类型`。

* 在`某个时间`，绑定到`引用的对象`始终具有`一种类型`，但给定`引用`可以在`程序执行过程中绑定到各种类型的对象`。

## 变量

* 在 Python 中，`没有"声明"`。`变量的存在始于绑定变量的语句`(换言之，`设置名称以保留对某个对象的引用`)。

* 当然也可以`取消绑定变量`，重设名称，使其不再保留引用。

* `赋值语句`是绑定变量和其他引用的最常用方法。`del 语句`用于取消绑定引用。

* 绑定已经绑定的引用称为`重新绑定`。重新绑定或取消绑定引用对引用所绑定的对象没有影响，当然`在对象没有引用时会被垃圾回收`。没有引用的对象的清理称为`垃圾回收`。

* `变量名不能使用`保留为 `Python 关键字`的标识符。

* 变量可以是全局变量或局部变量。`全局变量`是`模块对象的属性`。`局部变量`位于`函数的局部命名空间中`。

* 在 Python 中变量的作用域有：`函数作用域`，`模块作用域`。

### 对象的属性(attributes)和项(items)

* 对象的`属性`和`项`之间的主要`区别`在`于`用于`访问`它们的`语法`。

* 要访问对象的`属性`，使用`点语法(x.y)`，具体使用对该对象的引用，然后跟一个句点(`.`)，后跟一个称为属性名的标识符。

* 要访问对象的`项`，使用`下标访问语法(x[y])`，具体使用对该对象的引用，然后跟方括号([])并包裹一个表达式。方括号中的表达式称为项的索引或键，而对象称为项的容器。

* `可调用的属性`也称为`方法`。Python 在`可调用属性`和`不可调用属性`之间`没有严格区分`。`有关属性的所有规则也适用于可调用属性(方法)`。

### 访问不存在的引用

* 常见的`编程错误`是`试图访问不存在的引用`。

* Python `编译器`在`分析和编译源代码`时，`只`会`诊断语法错误`。编译`不`会`诊断语义错误`。

* Python 仅在错误代码执行时(即`运行时`)`诊断语义错误`。当某个操作是 Python `语义错误`的，尝试`执行该操作`会`引发异常`。

* `访问不存在`的`变量`，`属性`或`项`均`属于` Python `语义错误`，会`引发异常`。

## 赋值语句

* 赋值语句可以是`简单赋值`或`复合赋值`。

* `简单赋值`给`变量值`(`name=value`)是`创建新变量`或`将现有变量重新绑定到新值`的方式。

* 对`对象属性`的`简单赋值`(`x.attr=value`)是请求对对象`创建`或`重新绑定属性`。

* 对`容器`中某个`项`的`简单赋值`(`x[k]=value`)是请求对容器`创建`该`项`或将`索引或键重新绑定`。

* `复合赋值`本身`无法创建新的引用`。

* `复合赋值`可以`重新绑定变量`，请求对象`重新绑定`其现有属性或项之一，或请求目标对象`修改自身值`。

* 当请求对对象使用`复合赋值`时，由`对象决定`是否以及`如何满足请求`以及`是否抛出异常`。

### 简单赋值

* 最简单形式的`简单赋值语句语法`：`target(LHS) = expression(RHS)`

* 执行赋值时，Python 会`评估 expression`，然后将 expression 的值`绑定`到 `target`。

* `绑定不依赖于 expression 值的类型`。在赋值时，Python 在`可调用对象`和`不可调用对象`之间`没有严格区分`，因此可以将`函数`，`方法`，`类型`和`其他可调用对象`绑定到变​​量，就像可以`数字`，`字符串`，`列表`等`绑定到变量`一样。在 Python 中，`函数是一等公民`。

* `绑定依赖于 target 的类型`。赋值中的 target 可以是`标识符`，`属性引用`，`索引`或`切片`。

| target 的类型 | 语法 | 说明 |
| :-: | :-: | :-: |
| `标识符` | name = value | 将 value 与标识符(name)绑定 |
| `属性引用` | obj.name = value | 将 value 与对象 obj 的 name 属性绑定 |
| `索引(键)` | obj\[expr\] = value | 将 value 与容器 obj 的 expr 索引(键)指示的项绑定 |
| `切片` | obj\[start:stop:stride\] = value <br> obj[slice(start, stop, stride)] = value | 将 value 中的项与容器 obj 的切片指示的那些项绑定(`切片`中的`项`是`连续`的，对 `value` 中`项`的`个数没有要求`；`切片`中的`项不是连续`的，一般要求 `value` 中`项`的`个数`要与`切片中项`的`个数相等`) |

* 当赋值的 target 是`标识符`时，赋值语句完成`变量的绑定`。

* 一般情况下，针对`对象`使用赋值语句将`创建`或`重新绑定`一个或多个`属性`或`项`。

* `对象`可以`拒绝创建或重新绑定`某些(或全部)`属性`或`项`，如果`尝试赋值`禁止创建或重新绑定的属性或项，则会`引发异常`。

* 简单赋值可以有`多个 target`，它们需要使用`多个赋值运算符连接`起来。

```python
# 首先对最右边的表达式进行求值，然后将其值赋值给左边的每个 target
# 最右边的表达式，只求值一次
a = b = c = 0
```

* `拆箱赋值`：`左边`的`多个 target 使用逗号(,)分割`(可以使用`圆括号`或者`方括号`包裹所有 target)；`右边`的表达式需要返回一个`可迭代对象`，且其 `item 个数`与 `target 个数`相同，否则会抛出异常。item 与 target 之间进行`依次赋值绑定`。

```python
# x 需要是可迭代的对象
a, b, c = x
(a, b, c) = x
[a, b, c] = x
# 使用拆箱赋值交换变量
a, b = b, a
```

* 在 `v3` 中，`拆箱赋值`可以在 `target` 之前`使用` `*` 运算符，所有的 target 中`只能有一个` target 被`加星`。`所有没有被分配的值`都将`存入`一个 `list` 中，并将它`赋值给`这个`加星 target`。

```python
# 只能有一个加星 target
# 加星 target 的数据类型是 list
a = [1, 2, 3, 4, 5]
a1, *a2, a3 = a # a 至少要有两个元素。当 a 只有两个元素时，a2 为空 list
first, *middle, last = x
# 当 x 是一个 list 时，上述赋值与下面的赋值等价
first, middle, last = x[0], x[1:-1], x[-1]
```

### 复合赋值

* 在 target 和 expression 之间`使用复合赋值运算符`。

* 复合赋值运算符由`二元运算符`和(`后跟`)`赋值运算符`组成。具体的复合赋值运算符有 `+=` `-=` `*=` `/=` `//=` `%=` `**=` `|=` `>>=` `<<=` `&=` `^=` `@=`(v3)。

* 复合赋值的左边`只能`有`一个` `target`，复合赋值不支持多 target。

* 复合赋值的`处理流程`：
  1. `求值右边的表达式`；
  2. target `是否实现`了`二元运算符`对应的`特殊方法`？`实现了进入 3`，`没有实现进入 4`；
  3. target.\_\_method\_\_(表达式求值结果)。`修改 target 先前绑定的对象`；
  4. 将 target 引用的对象(操作数1)和表达式的求值结果(操作数2)一起作为`二元运算符`的操作数进行`运算`，最后将运算`结果赋值给`左边的 `target`。`重新绑定 target 到某个新对象`。

```python
# +=
x += y
# 实现了 __iadd__，等价于
x.__iadd__(y) # 修改 target
# 没有实现 __iadd__，等价于
x = x + y # 重新绑定 target
```

* `执行复合赋值前`的 `target 必须已经绑定了某个对象`。

* `复合赋值`可以`重新绑定 target 到某个新对象`，或`修改 target 先前绑定的对象`，但是`它永远不会创建新引用`。相对应的，`简单赋值`可以`创建新引用到某个对象`或`重新绑定 target 到某个对象`，但是`它永远都不能修改先前绑定的对象`。在这里需要`严格区分`：`对象`和`对对象的引用`。

```python
# 不修改 x 绑定的原对象，而是让 x 引用一个新对象(x + y 的求值结果)
x = x + y
# 对于
x += y
# 1. x 实现了 __iadd__，其结果为修改 x 引用的原对象
# 2. x 没有实现了 __iadd__，等价于 x = x + y，即让 x 引用一个新对象(x + y 的求值结果)
```

## del 语句

* `del 语句`本身`不删除对象`，它`只是取消引用与对象之间的绑定`(`解除绑定`)。当某个对象`不再存在任何引用`时，垃圾回收(`GC`)会自动`删除该对象`(`垃圾回收`)。

* del 语句由关键字 `del` 后跟`一个或多个 target` 引用构成，多个 target 之间使用`逗号(,)分隔`。每个 target 可以是`变量`，`属性引用`，`索引`或`切片`，并且必须在`执行 del 时`已经`绑定了对象`。

* 当 del 的 target 是标识符时，`del 语句`意味着`取消绑定变量`。

* 对于`对象属性或项`，del 语句以`解除一个或多个属性或项的绑定`。

* 对象可能`拒绝解除`某些(或全部)`属性或项`的`绑定`，如果`尝试`对其进行`解除`绑定(del 操作)，则会`引发异常`。

* `解除切片的绑定`通常与`为该切片分配空序列`具有`相同的效果`，`具体结果与容器对象的具体实现有关`。另外`容器`也`应该允许` del 操作导致的`副作用`。

```python
del C[2]
# 当 C 为字典时，这将使以后对 C[2] 的引用失效(引发 KeyError)，除非再次分配给 C[2] 对象
# 当 C 为列表时，del C[2] 意味着 C[2] 的每个后续项"向左移"一项。因此，如果 C 足够长，则对 C[2] 的引用仍然有效，但表示的是一个不同的项
```

## 变量、引用和对象的理解

```python
name = value
```

* `变量引用对象`

* name 为`变量`。

* value 为`对象`。

* name 和 value 之间的`关系`为：name `变量` `引用` value `对象`。
