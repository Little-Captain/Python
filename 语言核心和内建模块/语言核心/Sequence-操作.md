# Sequence 操作

* Python 支持适用于所有`序列`(包括字符串，列表和元组)的`各种操作`。

* `一些`序列操作`适用`于`所有容器`(包括不是序列的集合和字典)。

* `一些`序列操作`适用`于`所有可迭代对象`(`可循环`遍历的任何对象；所有`容器`，无论它们是否为序列，都是可迭代的；许多`不是容器的对象`也是可迭代的，如`生成器`对象)。

* 在本文中，需要非常`精确`地`使用`术语“`序列`”，“`容器`”和“`可迭代`”，以准确`指示`哪些`操作`适用于哪个`类别`。

## 一般 Sequence

* 序列是`有序容器`，其中包含可通过`索引`和`切片`访问的项。

* 内置的 `len` 函数将任何容器作为参数，并返回该容器中`项`的`个数`。

* 内置的 `min` 和 `max` 函数采用一个参数(一个非空的可迭代对象，其中的项是可比较的)，并分别返回`最小项`和`最大项`。

* 使用`多`个`参数`调用 `min` 和 `max`，在这种情况下，它们分别返回`最小参数`和`最大参数`。

* 内置的 `sum` 函数采用一个参数(一个可迭代对象，其中的项为数字)，并返回`数字`的`总和`。

### Sequence 转换

* 在不同的`序列`类型之间`没有隐式转换`(仅在 `v2` 中，Python 会`根据需要`将`字节字符串`转换为 `Unicode 字符串`)。

* 可以使用`单个参数`(任何`可迭代对象`)调用内置 `tuple` 和 `list`，来获取调用类型的`新实例`(`项`及其`顺序`与参数`保持一致`)。

### 连接与重复

* `+`: 可以`连接`相同类型的序列。

* `*`: `重复`连接序列指定的次数。

* `S * n` 或 `n * S` 是 S 的 `n 个副本`的`连接`。当 `n <= 0` 时，S * n 的结果是与 `S 类型相同`的`空序列`。

```python
# +
[1, 2] + [3] # [1, 2, 3]
# *
[1, 2] * 3 # [1, 2, 1, 2, 1, 2]
3 * [1, 2] # [1, 2, 1, 2, 1, 2]
[1, 2] * 0 # []
[1, 2] * -1 # []
```

### 测试关系

* `x in S` 用于测试`对象 x` 是否等于`序列 S` (或其他类型的容器或可迭代对象)中的任何`项`。x 在 S 中，返回 True，否则返回 False。

* `x not in S` 等价于 `not (x in S)`。

* 对于`字典`，`x in S` 测试 x 是否是 S 中`键`。

* 对于`字符串`，`x in S` 测试 x 是否等于 S 的任何`子字符串`，而不仅是单个字符。

### 索引访问序列

* 要表示序列 `S` 的第 `n` 项，可以使用索引：`S[n]`。

* 索引从 `0` 开始(S 的`第一项`是 `S[0]`)。

* 如果 `S 有 L 项`，则`索引 n` 可以为 `0、1 … 直至 L - 1(包括 L - 1)`，但`不能大于 L - 1`。

* n 也可以是 `-1，-2 … 向下至 -L`，但`不能小于 -L`。负数 `n` (例如 -1)与 `L + n` (例如 L + (-1))表示 S 中`相同的项`的索引。换句话说，`S[L - 1]` 和 `S[-1]` 都是 S 的`最后一个元素`，`S[L - 2]` 和 `S[-2]` 都是 S 的`倒数第二个元素`，依此类推。

* 当 `n < 0` 时，`n 索引` 等价于 `L + n 索引`

```python
x = [1, 2, 3, 4]
x[1] # 2
x[-1] # 4
```

* 索引 `>= L` 或 `< -L` 会引发`异常`。

### 切片访问序列

* 在 Python 中，`范围`始终`包含下限(开始)`，而`排除上限(结束)`。

* `切片中的负索引`与`索引中的负索引`意义相同。 即当 `n < 0(n 不能越界，如果越界，直接取边界值)` 时，`n 索引` 等价于 `L + n 索引`

* 索引 `>= L` 表示 `S 的结尾`，负索引 `<= -L` 表示 `S 的开头`。

* 要表示 S 的`子序列`，可以使用切片语法 `S[i:j]`，其中 i 和 j 是整数。

  * `S[i:j]` 是 S 从`第 i 项(包括)`到`第 j 项(不包括)`的`子序列`。

  * 当 `j <= i` 时，或当 `i >= L(S 的长度)` 时，`切片`是`空`的子`序列`。

  * 可以在 `i == 0 时省略 i`(从 S 的第一项开始)。可以在 `j >= L 时省略 j`(到 S 的最后一项结束)。可以同时`省略 i j 两个索引`，切片结果表示 `S 的浅拷贝`：S[:]。

* 切片的完备语法 `S[i:j:k]`。`k` 是切片的`跨度`，表示`连续索引`之间的`距离`。

  * `重点：` `S[i:j]` 等价于 `S[i:j:1]`。

  * `重点：` `未给出 i` 的情况下：当 `k > 0` 时，`i 取 0`；当 `k < 0` 时，`i 取 -1`。

  * `重点：` 在切片中 `i` `j` 可以取`任意`的`整数值`(即可以`越界`。如果`越界`，`取边界值`)。对 k，要求 `k != 0`，`否则`会`抛出异常`。

  * 当 `k == 0` 时，`S[i:j:k]` 抛出`异常`。

  * 当 `k != 0 且 i == j` 时，`S[i:j:k]` 返回`空序列`。

  * 当 `k > 0(顺序，从左到右取值)` 且 `i 的位置在 j 之前` 或 `k < 0(倒序，从右到左取值)` 且 `i 的位置在 j 之后` 时，`S[i:j:k]` 才`可能`返回`非空序列`。

  * 当 `k > 0` 时，`S[::k]` 等价于 `S[0:L:k]`。

  * 当 `k < 0` 时，`S[::k]` 等价于 `S[-1:-(L+1):k]`。

  * `重点：` `S[i:j:k]` 进行`切片`的`过程`：首先确定 `S[i]` 和 `S[j]` `项`及其在序列中的`位置`，然后按 `k`(`> 0，顺序，从左到右取值`；`< 0，倒序，从右到左取值`) 跨度在 `S` 中`取值`，并将`值`依次`存入`作为`结果`返回的`子序列`中，最后`返回结果`。注意`取值`时，`i` `j` 索引的`大小`关系`不重要`，`位置`关系`很重要`。取值时，脑海中可以首先`想象`出`一条数轴`，然后`标记`出 `i` `j` 索引的`位置`，然后按 `k` 跨度`从 i 向 j` 移动索引的同时在序列上`取值`，最终返回`结果子序列`。

```python
S[i:j]
# 等价于
S[i:j:1]
S[::2] # S 中具有偶数索引的所有项目组成的子序列
S[::-1] # S 中的所有项，但顺序相反
```

```python
x = [1, 2, 3, 4]
x[1:3] # [2, 3]
x[1:] # [2, 3, 4]
x[:2] # [1, 2]
```

```python
y = list(range(10))
y[-5:] # [5, 6, 7, 8, 9]
y[::2] # [0, 2, 4, 6, 8]
y[10:0:-2] # [9, 7, 5, 3, 1]
y[:0:-2] # [9, 7, 5, 3, 1]
y[::-2] # [9, 7, 5, 3, 1]
```

## 字符串(String)

* `字符串对象`(`字节`字符串，以及 `Unicode` 字符串)是`不可变`的：尝试`重新绑定`或`删除`字符串中的项或切片会引发`异常`。

* `字符串对象`中的`项`(对应于字符串中的每个字符)`本身`就是相同类型的`字符串`，对于“`单个字符`”`没有特殊`的`数据类型`(在 `v3` 中的`字节字符串`对象的`项`除外，在这种情况下，`索引`某项将`返回`一个 `int`)。

```python
a = b'abc'
a[0] # 97
```

* `字符串`的所有`切片`都是`相同类型`的`字符串`。

## 元组(Tuple)

* `元组对象`是`不可变`的：因此，尝试`重新绑定`或`删除`元组的`项`或`切片`会引发`异常`。

* `元组`的`项`是`任意对象`，并且`可以`是`不同`的`类型`；元组`项可能是易变的`，但`不建议这样做`，因为这样做可能会造成混淆。

* 元组的`切片`也是`元组`。元组的 `count` 和 `index` 含义与`列表相同`。

## 列表(List)

* `列表对象`是`可变`的：可以`重新绑定`或`删除`列表的`项`和`切片`。

* `列表`的`项`是`任意对象`，并且`可以`具有`不同`的`类型`。

* 列表的`切片`也是`列表`。

### 列表的修改

### 列表的就地操作

### 列表的方法

### 列表的排序
