# Sequence 操作

* Python 支持适用于所有`序列`(包括字符串，列表和元组)的`各种操作`。

* `一些`序列操作`适用`于`所有容器`(包括不是序列的集合和字典)。

* `一些`序列操作`适用`于`所有可迭代对象`(`可循环`遍历的任何对象；所有`容器`，无论它们是否为序列，都是可迭代的；许多`不是容器的对象`也是可迭代的，如`生成器`对象)。

* 在本文中，需要非常`精确`地`使用`术语“`序列`”，“`容器`”和“`可迭代`”，以准确`指示`哪些`操作`适用于哪个`类别`。

## 一般 Sequence

* 序列是`有序容器`，其中包含可通过`索引`和`切片`访问的项。

* 内置的 `len` 函数将任何容器作为参数，并返回该容器中`项`的`个数`。

* 内置的 `min` 和 `max` 函数采用一个参数(一个非空的可迭代对象，其中的项是可比较的)，并分别返回`最小项`和`最大项`。

* 使用`多`个`参数`调用 `min` 和 `max`，在这种情况下，它们分别返回`最小参数`和`最大参数`。

* 内置的 `sum` 函数采用一个参数(一个可迭代对象，其中的项为数字)，并返回`数字`的`总和`。

### Sequence 转换

* 在不同的`序列`类型之间`没有隐式转换`(仅在 `v2` 中，Python 会`根据需要`将`字节字符串`转换为 `Unicode 字符串`)。

* 可以使用`单个参数`(任何`可迭代对象`)调用内置 `tuple` 和 `list`，来获取调用类型的`新实例`(`项`及其`顺序`与参数`保持一致`)。

### 连接与重复

* `+`: 可以`连接`相同类型的序列。

* `*`: `重复`连接序列指定的次数。

* `S * n` 或 `n * S` 是 S 的 `n 个副本`的`连接`。当 `n <= 0` 时，S * n 的结果是与 `S 类型相同`的`空序列`。

```python
# +
[1, 2] + [3] # [1, 2, 3]
# *
[1, 2] * 3 # [1, 2, 1, 2, 1, 2]
3 * [1, 2] # [1, 2, 1, 2, 1, 2]
[1, 2] * 0 # []
[1, 2] * -1 # []
```

### 测试关系

* `x in S` 用于测试`对象 x` 是否等于`序列 S` (或其他类型的容器或可迭代对象)中的任何`项`。x 在 S 中，返回 True，否则返回 False。

* `x not in S` 等价于 `not (x in S)`。

* 对于`字典`，`x in S` 测试 x 是否是 S 中`键`。

* 对于`字符串`，`x in S` 测试 x 是否等于 S 的任何`子字符串`，而不仅是单个字符。

### 索引访问序列

* 要表示序列 `S` 的第 `n` 项，可以使用索引：`S[n]`。

* 索引从 `0` 开始(S 的`第一项`是 `S[0]`)。

* 如果 `S 有 L 项`，则`索引 n` 可以为 `0、1 … 直至 L - 1(包括 L - 1)`，但`不能大于 L - 1`。

* n 也可以是 `-1，-2 … 向下至 -L`，但`不能小于 -L`。负数 `n` (例如 -1)与 `L + n` (例如 L + (-1))表示 S 中`相同的项`的索引。换句话说，`S[L - 1]` 和 `S[-1]` 都是 S 的`最后一个元素`，`S[L - 2]` 和 `S[-2]` 都是 S 的`倒数第二个元素`，依此类推。

* 当 `n < 0` 时，`n 索引` 等价于 `L + n 索引`

```python
x = [1, 2, 3, 4]
x[1] # 2
x[-1] # 4
```

* 索引 `>= L` 或 `< -L` 会引发`异常`。

### 切片访问序列

* 在 Python 中，`范围`始终`包含下限(开始)`，而`排除上限(结束)`。

* `切片中的负索引`与`索引中的负索引`意义相同。 即当 `n < 0(n 不能越界，如果越界，直接取边界值)` 时，`n 索引` 等价于 `L + n 索引`

* 索引 `>= L` 表示 `S 的结尾`，负索引 `<= -L` 表示 `S 的开头`。

* 要表示 S 的`子序列`，可以使用切片语法 `S[i:j]`，其中 i 和 j 是整数。

  * `S[i:j]` 是 S 从`第 i 项(包括)`到`第 j 项(不包括)`的`子序列`。

  * 当 `j <= i` 时，或当 `i >= L(S 的长度)` 时，`切片`是`空`的子`序列`。

  * 可以在 `i == 0 时省略 i`(从 S 的第一项开始)。可以在 `j >= L 时省略 j`(到 S 的最后一项结束)。可以同时`省略 i j 两个索引`，切片结果表示 `S 的浅拷贝`：S[:]。

* 切片的完备语法 `S[i:j:k]`。`k` 是切片的`跨度`，表示`连续索引`之间的`距离`。

  * `重点：` `S[i:j]` 等价于 `S[i:j:1]`。

  * `重点：` `未给出 i` 的情况下：当 `k > 0` 时，`i 取 0`；当 `k < 0` 时，`i 取 -1`。

  * `重点：` 在切片中 `i` `j` 可以取`任意`的`整数值`(即可以`越界`。如果`越界`，`取边界值`)。对 k，要求 `k != 0`，`否则`会`抛出异常`。

  * 当 `k == 0` 时，`S[i:j:k]` 抛出`异常`。

  * 当 `k != 0 且 i == j` 时，`S[i:j:k]` 返回`空序列`。

  * 当 `k > 0(顺序，从左到右取值)` 且 `i 的位置在 j 之前` 或 `k < 0(倒序，从右到左取值)` 且 `i 的位置在 j 之后` 时，`S[i:j:k]` 才`可能`返回`非空序列`。

  * 当 `k > 0` 时，`S[::k]` 等价于 `S[0:L:k]`。

  * 当 `k < 0` 时，`S[::k]` 等价于 `S[-1:-(L+1):k]`。

  * `重点：` `S[i:j:k]` 进行`切片`的`过程`：首先确定 `S[i]` 和 `S[j]` `项`及其在序列中的`位置`，然后按 `k`(`> 0，顺序，从左到右取值`；`< 0，倒序，从右到左取值`) 跨度在 `S` 中`取值`，并将`值`依次`存入`作为`结果`返回的`子序列`中，最后`返回结果`。注意`取值`时，`i` `j` 索引的`大小`关系`不重要`，`位置`关系`很重要`。取值时，脑海中可以首先`想象`出`一条数轴`，然后`标记`出 `i` `j` 索引的`位置`，然后按 `k` 跨度`从 i 向 j` 移动索引的同时在序列上`取值`，最终返回`结果子序列`。

```python
S[i:j]
# 等价于
S[i:j:1]
S[::2] # S 中具有偶数索引的所有项目组成的子序列
S[::-1] # S 中的所有项，但顺序相反
```

```python
x = [1, 2, 3, 4]
x[1:3] # [2, 3]
x[1:] # [2, 3, 4]
x[:2] # [1, 2]
```

```python
y = list(range(10))
y[-5:] # [5, 6, 7, 8, 9]
y[::2] # [0, 2, 4, 6, 8]
y[10:0:-2] # [9, 7, 5, 3, 1]
y[:0:-2] # [9, 7, 5, 3, 1]
y[::-2] # [9, 7, 5, 3, 1]
```

## 字符串(String)

* `字符串对象`(`字节`字符串，以及 `Unicode` 字符串)是`不可变`的：尝试`重新绑定`或`删除`字符串中的项或切片会引发`异常`。

* `字符串对象`中的`项`(对应于字符串中的每个字符)`本身`就是相同类型的`字符串`，对于“`单个字符`”`没有特殊`的`数据类型`(在 `v3` 中的`字节字符串`对象的`项`除外，在这种情况下，`索引`某项将`返回`一个 `int`)。

```python
a = b'abc'
a[0] # 97
```

* `字符串`的所有`切片`都是`相同类型`的`字符串`。

## 元组(Tuple)

* `元组对象`是`不可变`的：因此，尝试`重新绑定`或`删除`元组的`项`或`切片`会引发`异常`。

* `元组`的`项`是`任意对象`，并且`可以`是`不同`的`类型`；元组`项可能是易变的`，但`不建议这样做`，因为这样做可能会造成混淆。

* 元组的`切片`也是`元组`。元组的 `count` 和 `index` 含义与`列表相同`。

## 列表(List)

* `列表对象`是`可变`的：可以`重新绑定`或`删除`列表的`项`和`切片`。

* `列表`的`项`是`任意对象`，并且`可以`具有`不同`的`类型`。

* 列表的`切片`也是`列表`。

### 列表的修改

* 可以通过`分配`给`索引`某个`新值`来`修改`列表中的单个`项`。

```python
x = [1, 2, 3, 4]
x[1] = 42 # x => [1, 42, 3, 4]
```

* `修改`列表对象 L 的`另一种方法`是使用 L 的`切片`作为`赋值`语句的 `target(LHS)`。分配的 `RHS` 必须是`可迭代的对象`。当 `LHS` 切片为扩展形式时(即切片`跨度 != 1`)，则 `RHS` 必须具有与 `LHS` 切片中的`项数一样`多的项。当 `LHS` 切片未指定跨度或明确指定`跨度为 1` 时，`LHS` 切片和 `RHS` 可以`各自`为`任意长度`；`分配`给`列表的切片`可以`使列表更长或更短`。

```python
x = [1, 2, 3, 4]
x[1:3] = [22, 33, 44] # [1, 2, 3, 4] => [1, 22, 33, 44, 4]
x[1:4] = [8, 9] # [1, 22, 33, 44, 4] => [1, 8, 9, 4]
```

* `给切片赋值`的一些`特殊情况`：
  * 使用空列表 `[]` 作为 `RHS` 表达式可`从 L 中删除目标切片`。换句话说，`L[i:j] = []` 与 `del L[i:j]` 具有相同的作用(或特殊语句 `L[i:j] *= 0`)。
  * 使用`空的 L 切片`作为 `LHS` 目标，将 `RHS` 的项`插入` L 的`适当位置`(如，`L[i:i] = ['a'，'b']` 将 `'a'` 和 `'b'` `插入`在赋值之前位于 L 中索引 `i` 的项`之前`的`位置`)。
  * 使用`覆盖整个列表对象`的`切片 L[:]` 作为 `LHS` 目标，可以`完全替换 L` 的内容。

```python
x = [1, 2, 3, 4]
x[1:3] = [] # [1, 2, 3, 4] => [1, 4]，等价于 del x[1:3] 或 x[1:3] *= 0

x = [1, 2, 3, 4]
x[1:1] = [8, 9] # [1, 2, 3, 4] => [1, 8, 9, 2, 3, 4]

x = [1, 2, 3, 4]
x[:] = [5, 6, 7, 8, 9] # [1, 2, 3, 4] => [5, 6, 7, 8, 9]
```

* 使用 del 从列表中删除项或切片。

```python
x = [1, 2, 3, 4]
del x[0] # [1, 2, 3, 4] => [2, 3, 4]

x = [1, 2, 3, 4]
del x[1:3] # [1, 2, 3, 4] => [1, 4]

x = [1, 2, 3, 4]
del x[::2] # [1, 2, 3, 4] => [2, 4]
```

### 列表的就地操作

* 列表对象定义了 `+` 和 `*` 运算符的就地版本，可以`通过扩展的赋值语句`使用它们。

* 就像 `L.extend(L1)` 一样，扩充后的赋值语句 `L += L1` 具有`将可迭代对象 L1 的项添加到 L 的末尾`的作用。

* `L *= n` 具有将 `L` 的 `n - 1 个副本添加到 L 的末尾`的作用；如果 `n <= 0`，则 `L *= n 清空 L 的内容`，和 `L[:] = []` 的`结果一样`。

```python
a = [1, 2, 3]
b = [4, 5]
a += b # [1, 2, 3] => [1, 2, 3, 4, 5]

a = [1, 2, 3]
a *= 3 # [1, 2, 3] => [1, 2, 3, 1, 2, 3, 1, 2, 3]

a = [1, 2, 3]
a *= 0 # [1, 2, 3] => []

a = [1, 2, 3]
a *= -1 # [1, 2, 3] => []
```

### 列表的方法

* 列表对象提供了一些方法。`不可变方法不改变其应用的对象`而`返回新结果`，而`可变方法`则`可以改变其应用的对象`。

* 列表的`许多可变方法`的行为都`类似`于对`列表`的`适当切片`的`赋值`操作。

* 在下表中，`L` 表示任意列表对象，`i` 是 L 中的任意有效索引，`s` 是可迭代对象，`x` 是任意对象。

| 方法 | 描述 | 可变性(是否能改变 L) |
| :-: | :-: | :-: |
| L.count(x) | 返回 L 中`等于 x` 的`项数` | 不可变 |
| L.index(x) | 返回 L 中`第一个等于 x` 的`项`的`索引`，如果 L 中`没有这样的项`，则会`引发异常` | 不可变 |
| L.append(x) | 将`项 x` `追加`到 `L` 的`末尾`；其结果与 `L[len(L):] = [x]` 一样 | 可变 |
| L.extend(s) | 将`可迭代对象`的`所有项`都`追加`到 `L` 的末尾；其结果与 `L[len(L):] = s` 或 `L += s` 一样 | 可变 |
| L.insert(i, x) | 将 L 中索引为 `i 的项及其右边的所有项`都`向右移动`，以`留出 1 个索引位置`，然后将`项 x 插入 L 中索引为 i 的位置`(刚刚留出的位置)。操作结果与 `L[i:i] = [x]` 一样。`len(L) 增加 1`，`不会替换任何项`，`不会引发异常`(即使 `i 越界`，也不会。`i <= -len(L)`，在`开始`位置插入；`i >= len(L)`，在`结束`位置插入。)。 | 可变 |
| L.remove(x) | 移除 L 中`第一个等于 x` 的`项`，如果 L 中`没有这样的项`，则会`引发异常` | 可变 |
| L.pop(i=-1) | `返回`索引 `i` 处的`项`，并将其`从 L 中删除`；当`省略 i` 时，`删除并返回` L 的`最后一项`；如果 `L 为空`或 `i` 是 L 中的`无效`索引，则会`引发异常` | 可变 |
| L.reverse() | `逆转` L 中的`所有项` | 可变 |
| L.sort(cmp=cmp, key=None, reverse=False) | 对 L 的`项`进行就地`排序`，通过`命名参数 cmp` 传递的函数(默认情况下为`内置函数 cmp`)成对比较项(`仅 v2 适用`)。如果`参数 key` 不为 None，则对每个项 x 进行比较的是 `key(x)`，而不是 x 本身。在 `v2` 中 `cmp` 也已被`废弃`，在 `v3` 中根本`不存在` `cmp` | 可变 |

* 除了 `pop`(`返回删除的项`) 之外，列表对象的`所有可变方法`均`返回 None`。

### 列表的排序

* 列表的 `sort` 方法使列表以`稳定`的方式(`不`会`交换相等的元素`)进行`就地排序`(重新排序元素以使它们按升序排列)。

* 实际上，使用 `sort` 方法排序`非常快`，因为它可以`利用`任何`子列表`中`可能存在`的任何`正序`或`逆序`(这种高级排序算法被称为 `timsort`)。

* 在 `v2` 中，sort 方法采用`三个可选参数`，可以使用`位置参数`或`命名参数`语法传递这些参数。

* 在 `v2` 中，参数 `cmp` 已废弃。如果`存在`，则`必须是一个函数`。当以任意两个列表项作为参数调用时(`cmp(x, y)`)，该函数将返回 `-1(x < y)`、`0(x == y)` 或 `1(x > y)`。如果`不存在`，则使用默认的`内置函数 cmp`。

* 如果参数 `key 不是 None`，则`必须是一个可以使用任何列表项作为其唯一参数的函数`。这时，为了比较列表中的任何两项(x 和 y)，Python 使用 `cmp(key(x), key(y))` 而不是 cmp(x, y)。

* 如果参数 `reverse` 为 `True`，则将导致`每个比较的结果`都被`反转`；这与`排序后反转`列表并`不相同`，因为无论参数 reverse 是 True 还是 False，`排序`都是`稳定`的(`相等的元素永远不会交换`)。

* `v3` 的排序方式与 `v2` 的`排序方式一样`。sort 方法的`区别`：在 `v2` 中`不推荐`使用 `cmp 参数`，在 `v3` 中根本`不存在` `cmp 参数`。

* Python 还提供了内置函数 `sorted`，它可以根据传入的`任何可迭代对象`生成`已排序的列表`。sorted 函数的`第一个参数`为`可迭代对象`，`其他参数`与`列表的排序方法相同`。

* 标准库模块 `operator` 中提供了高阶函数 `attrgetter` 和 `itemgetter`，它们`产生的函数`特别`适合`于`传递`给列表的 `sort 方法`或内置`函数 sorted` 的 `key` 可选参数。对于内置函数 `min` 和 `max` 以及标准库模块 heapq 中 `nsmallest` 和 `nlargest` 函数，也存在相同的 `key` 可选参数，这些 key 可选参数`同样适用上述规则产生的函数`。
